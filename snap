===== ./main.py =====
# main.py
import order_manager
import time
import threading
import gc
import requests
import json
from exchange import check_connection, ex
from patterns import check_scob_pattern, wait_for_candle_close
from telegram import send_startup_message, send_telegram_message, send_error_message
from callback_handler import handle_callback
from config import TELEGRAM_BOT_TOKEN, SYMBOL
from levels_monitor import LevelMonitor

def get_updates(offset=None):
    """Get updates from Telegram via polling"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'timeout': 30, 'offset': offset}
    try:
        response = requests.get(url, params=params, timeout=35)
        return response.json()
    except:
        return {'result': []}

def process_updates():
    """Process Telegram updates in background"""
    last_update_id = None
    print("Starting Telegram updates polling...")

    while True:
        try:
            updates = get_updates(last_update_id)
            if updates.get('result'):
                for update in updates['result']:
                    if 'callback_query' in update:
                        callback_data = update['callback_query']['data']
                        print(f"Received callback: {callback_data}")
                        handle_callback(callback_data)
                    last_update_id = update['update_id'] + 1

            time.sleep(1)
        except Exception as e:
            print(f"Updates error: {e}")
            time.sleep(5)

def monitor_levels():
    """Monitor 4H levels for breakouts"""
    monitor = LevelMonitor()
    monitor.update_levels(send_message=True)

    current_high_level = monitor.last_4h_high
    current_low_level = monitor.last_4h_low
    high_breakout_reported = False
    low_breakout_reported = False
    last_high_msg = 0
    last_low_msg = 0
    MIN_MSG_INTERVAL = 300  # 5 –º–∏–Ω—É—Ç

    print("Level monitor started - tracking 4H breakouts")

    while True:
        try:
            current_time = time.time()
            # –û–±–Ω–æ–≤–ª—è–µ–º —É—Ä–æ–≤–Ω–∏ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
            if current_time % 300 < 30:
                old_high = current_high_level
                old_low = current_low_level
                if monitor.update_levels(send_message=False):
                    current_high_level = monitor.last_4h_high
                    current_low_level = monitor.last_4h_low
                    high_breakout_reported = False
                    low_breakout_reported = False

            ticker = ex.fetch_ticker(SYMBOL)
            current_price = ticker["last"]

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ—è –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
            if current_high_level and current_price > current_high_level:
                if not high_breakout_reported or (time.time() - last_high_msg > MIN_MSG_INTERVAL):
                    message = f"High break {current_high_level:.2f}"
                    send_telegram_message("", "", "", "", message)
                    print(f"LevelMonitor: {message}")
                    high_breakout_reported = True
                    last_high_msg = time.time()
                    low_breakout_reported = False

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ—è –Ω–∏–∂–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
            elif current_low_level and current_price < current_low_level:
                if not low_breakout_reported or (time.time() - last_low_msg > MIN_MSG_INTERVAL):
                    message = f"Low break: {current_low_level:.2f}"
                    send_telegram_message("", "", "", "", message)
                    print(f"LevelMonitor: {message}")
                    low_breakout_reported = True
                    last_low_msg = time.time()
                    high_breakout_reported = False

            # –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ —Ü–µ–Ω—ã –≤ –¥–∏–∞–ø–∞–∑–æ–Ω
            elif current_high_level and current_low_level:
                if current_low_level <= current_price <= current_high_level:
                    if high_breakout_reported or low_breakout_reported:
                        print(f"LevelMonitor: Price returned to range {current_low_level:.2f} - {current_high_level:.2f}, resetting breakout flags")
                        high_breakout_reported = False
                        low_breakout_reported = False

            time.sleep(30)

        except Exception as e:
            print(f"Level monitor error: {e}")
            time.sleep(60)

def main():
    print("Starting ScoB Bot...")
    print("Monitoring patterns...")

    send_startup_message()

    if not check_connection():
        return

    polling_thread = threading.Thread(target=process_updates, daemon=True)
    polling_thread.start()
    print("Telegram polling started")

    level_thread = threading.Thread(target=monitor_levels, daemon=True)
    level_thread.start()
    print("Level monitor started")

    last_signal_time = 0

    while True:
        try:
            wait_for_candle_close()
            signal = check_scob_pattern()

            if signal:
                current_time = int(time.time() * 1000)
                if current_time - last_signal_time > 60000:
                    send_telegram_message(
                        signal["title"],
                        signal["time"],
                        signal["entry"],
                        signal["stop_loss"],
                        signal["take_profit"]
                    )
                    last_signal_time = current_time

            gc.collect()
            time.sleep(6)

        except KeyboardInterrupt:
            print("Bot stopped manually")
            break
        except Exception as e:
            print(f"Bot error: {e}")
            send_error_message(str(e))
            time.sleep(30)

if __name__ == "__main__":
    main()
===== ./levels_monitor.py =====
# levels_monitor.py
import ccxt
import asyncio
import time
from datetime import datetime
from exchange import ex, SYMBOL
from telegram import send_telegram_message

class LevelMonitor:
    def __init__(self):
        self.last_4h_high = None
        self.last_4h_low = None
        self.last_candle_timestamp = None
        self.levels_sent = False
        self.last_update_time = 0
        print("Level Monitor initialized - 4H levels will be sent on new candle close")

    def update_levels(self, send_message=True):
        """–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º - –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É—Ä–æ–≤–Ω–∏ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ"""
        current_time = time.time()
        
        # –ï—Å–ª–∏ —É—Ä–æ–≤–Ω–∏ –µ—â–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏—Å—å, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏—Ö
        if not self.levels_sent:
            candles = ex.fetch_ohlcv(SYMBOL, "4h", limit=3)
            if len(candles) >= 2:
                previous_closed_candle = candles[-2]
                self.calculate_and_send_levels_sync(previous_closed_candle)
                return True
        return False

    def calculate_and_send_levels_sync(self, closed_candle):
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
        try:
            # closed_candle = [timestamp, open, high, low, close, volume]
            timestamp, open_price, high, low, close, volume = closed_candle
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º High/Low –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø—Ä–æ–±–æ–µ–≤
            self.last_4h_high = high
            self.last_4h_low = low
            
            # –†–∞—Å—á–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
            levels = self.calculate_support_resistance(high, low, close)
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            message = self.format_levels_message(levels, timestamp)
            send_telegram_message("4H_levels", "", "", "", message)
            
            self.levels_sent = True
            self.last_update_time = time.time()
            print(f"‚úÖ 4H —É—Ä–æ–≤–Ω–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –ø–æ –∑–∞–∫—Ä—ã—Ç–æ–π —Å–≤–µ—á–µ")
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —É—Ä–æ–≤–Ω–µ–π: {e}")

    def calculate_support_resistance(self, high, low, close):
        """–†–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω–µ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è"""
        # Pivot Points –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–µ
        pivot = (high + low + close) / 3
        r1 = (2 * pivot) - low
        s1 = (2 * pivot) - high
        r2 = pivot + (high - low)
        s2 = pivot - (high - low)
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É—Ä–æ–≤–Ω–∏
        resistance_levels = [
            round(r1, 2),
            round(r2, 2),
            round(high, 2)  # –ø—Ä–µ–¥—ã–¥—É—â–∏–π –º–∞–∫—Å–∏–º—É–º
        ]
        
        support_levels = [
            round(s1, 2),
            round(s2, 2), 
            round(low, 2)   # –ø—Ä–µ–¥—ã–¥—É—â–∏–π –º–∏–Ω–∏–º—É–º
        ]
        
        # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º
        resistance_levels = sorted(list(set(resistance_levels)))
        support_levels = sorted(list(set(support_levels)))
        
        return {
            'support': support_levels,
            'resistance': resistance_levels,
            'pivot': round(pivot, 2),
            'high': round(high, 2),
            'low': round(low, 2),
            'timestamp': datetime.now()
        }

    def format_levels_message(self, levels, candle_timestamp):
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —É—Ä–æ–≤–Ω—è–º–∏"""
        candle_time = datetime.fromtimestamp(candle_timestamp/1000).strftime('%H:%M %d.%m')
        
        supports = ", ".join([f"`{s}`" for s in levels['support']])
        resistances = ", ".join([f"`{r}`" for r in levels['resistance']])
        
        return f"""
üìä **4H –£—Ä–æ–≤–Ω–∏ {SYMBOL}** ({candle_time})

üõü **–ü–æ–¥–¥–µ—Ä–∂–∫–∞:** {supports}
üéØ **–°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ:** {resistances}  
‚öñÔ∏è **Pivot:** `{levels['pivot']}`
üìà **High:** `{levels['high']}`
üìâ **Low:** `{levels['low']}`

_–û–±–Ω–æ–≤–ª–µ–Ω–æ: {datetime.now().strftime('%H:%M:%S')}_
"""

def monitor_levels():
    """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ 4H —É—Ä–æ–≤–Ω–µ–π –¥–ª—è –ø—Ä–æ–±–æ–µ–≤ (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å —Ç–µ–∫—É—â–∏–º –∫–æ–¥–æ–º)"""
    monitor = LevelMonitor()
    
    # –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —É—Ä–æ–≤–Ω–µ–π
    monitor.update_levels(send_message=True)

    current_high_level = monitor.last_4h_high
    current_low_level = monitor.last_4h_low
    high_breakout_reported = False
    low_breakout_reported = False
    last_high_msg = 0
    last_low_msg = 0
    MIN_MSG_INTERVAL = 300  # 5 –º–∏–Ω—É—Ç

    print("Level monitor started - tracking 4H breakouts")

    while True:
        try:
            current_time = time.time()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—É—é —Å–≤–µ—á—É –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
            candles = ex.fetch_ohlcv(SYMBOL, "4h", limit=3)
            if len(candles) >= 2:
                latest_candle = candles[-1]
                previous_closed_candle = candles[-2]
                
                candle_timestamp = latest_candle[0]
                
                # –ï—Å–ª–∏ –ø–æ—è–≤–∏–ª–∞—Å—å –Ω–æ–≤–∞—è —Å–≤–µ—á–∞
                if candle_timestamp != monitor.last_candle_timestamp:
                    print(f"üïØÔ∏è –ù–æ–≤–∞—è 4H —Å–≤–µ—á–∞: {datetime.fromtimestamp(candle_timestamp/1000)}")
                    monitor.last_candle_timestamp = candle_timestamp
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º —É—Ä–æ–≤–Ω–∏ –ø–æ –Ω–æ–≤–æ–π —Å–≤–µ—á–µ
                    monitor.calculate_and_send_levels_sync(previous_closed_candle)
                    current_high_level = monitor.last_4h_high
                    current_low_level = monitor.last_4h_low
                    high_breakout_reported = False
                    low_breakout_reported = False

            ticker = ex.fetch_ticker(SYMBOL)
            current_price = ticker["last"]

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ—è –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
            if current_high_level and current_price > current_high_level:
                if not high_breakout_reported or (time.time() - last_high_msg > MIN_MSG_INTERVAL):
                    message = f"High break {current_high_level:.2f}"
                    send_telegram_message("", "", "", "", message)
                    print(f"LevelMonitor: {message}")
                    high_breakout_reported = True
                    last_high_msg = time.time()
                    low_breakout_reported = False

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ—è –Ω–∏–∂–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
            elif current_low_level and current_price < current_low_level:
                if not low_breakout_reported or (time.time() - last_low_msg > MIN_MSG_INTERVAL):
                    message = f"Low break: {current_low_level:.2f}"
                    send_telegram_message("", "", "", "", message)
                    print(f"LevelMonitor: {message}")
                    low_breakout_reported = True
                    last_low_msg = time.time()
                    high_breakout_reported = False

            # –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ —Ü–µ–Ω—ã –≤ –¥–∏–∞–ø–∞–∑–æ–Ω
            elif current_high_level and current_low_level:
                if current_low_level <= current_price <= current_high_level:
                    if high_breakout_reported or low_breakout_reported:
                        print(f"LevelMonitor: Price returned to range {current_low_level:.2f} - {current_high_level:.2f}, resetting breakout flags")
                        high_breakout_reported = False
                        low_breakout_reported = False

            time.sleep(30)

        except Exception as e:
            print(f"Level monitor error: {e}")
            time.sleep(60)
===== ./order_manager.py =====
from event_bus import subscribe

def handle_button_click(data):
    print("ORDER_MANAGER: Received button click:", data)
    
    action = data.get("action")
    price = data.get("price")
    
    if action == "BUY_LIMIT":
        print(f"TEST_ORDER: Would create BUY LIMIT at {price}")
    elif action == "SELL_LIMIT":
        print(f"TEST_ORDER: Would create SELL LIMIT at {price}")
    elif action == "BUY_MARKET":
        print("TEST_ORDER: Would create BUY MARKET (current price)")
    elif action == "SELL_MARKET":
        print("TEST_ORDER: Would create SELL MARKET (current price)")

subscribe("BUTTON_CLICK", handle_button_click)===== ./callback_handler.py =====
from event_bus import publish

def handle_callback(query_data):
    print("CALLBACK_HANDLER: Received callback:", query_data)
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä—ã–Ω–æ—á–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞ –±–µ–∑ —Ü–µ–Ω—ã
    if ':' in query_data:
        # –õ–∏–º–∏—Ç–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞: BUY_LIMIT:3800.50
        action, price = query_data.split(':')
        publish("BUTTON_CLICK", {"action": action, "price": price})
    else:
        # –†—ã–Ω–æ—á–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞: BUY_MARKET, SELL_MARKET
        publish("BUTTON_CLICK", {"action": query_data, "price": None})===== ./patterns.py =====
# patterns.py
import time
from datetime import datetime
from exchange import fetch_candles, ex, SYMBOL
from config import CANDLES_NEEDED
import statistics

def wait_for_candle_close():
    """Wait for current candle to close"""
    current_time = int(time.time() * 1000)
    candle_duration = 300000  # 5 minute
    next_candle_time = (current_time // candle_duration + 1) * candle_duration
    wait_time = (next_candle_time - current_time) / 1000
    if wait_time > 0:
        print(f"Waiting for candle close: {wait_time:.1f} sec")
        time.sleep(wait_time)

def check_scob_pattern():
    """Check ScoB pattern on closed candles - returns signal data or None"""
    print("Analyzing candles for ScoB pattern...")
    
    candles = fetch_candles(limit=CANDLES_NEEDED)
    if len(candles) < CANDLES_NEEDED:
        print("Not enough candles for analysis")
        return None

    # === ATR —Ñ–∏–ª—å—Ç—Ä ===
    atr_candles = ex.fetch_ohlcv(SYMBOL, "5m", limit=20)
    trs = []
    for i in range(1, len(atr_candles)):
        high = atr_candles[i][2]
        low = atr_candles[i][3]
        prev_close = atr_candles[i - 1][4]
        tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
        trs.append(tr)
    atr = statistics.mean(trs)

    # Candle 1 (oldest) - –∏–Ω–¥–µ–∫—Å -3
    high1 = candles[-3][2]
    low1 = candles[-3][3]

    # Candle 2 (ScoB pattern) - –∏–Ω–¥–µ–∫—Å -2  
    high2 = candles[-2][2]
    low2 = candles[-2][3]
    close2 = candles[-2][4]

    # Candle 3 (confirmation) - –∏–Ω–¥–µ–∫—Å -1
    high3 = candles[-1][2]
    low3 = candles[-1][3] 
    close3 = candles[-1][4]

    time_str = datetime.fromtimestamp(candles[-1][0] / 1000).strftime('%H:%M')

    print(f"Candles data:")
    print(f"  Candle 1: H:{high1:.2f} L:{low1:.2f}")
    print(f"  Candle 2: H:{high2:.2f} L:{low2:.2f} C:{close2:.2f}")
    print(f"  Candle 3: H:{high3:.2f} L:{low3:.2f} C:{close3:.2f}")

    # ATR —Ñ–∏–ª—å—Ç—Ä: –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–∞–±—ã–µ —Å–≤–µ—á–∏
    candle_range = high2 - low2
    if candle_range < atr * 0.7:
        print(f"ATR filter: range {candle_range:.2f} too small vs ATR {atr:.2f}, skip")
        return None

    # LONG: ScoB down + close above high2
    if (low2 < low1 and close2 > low1 and close3 > high2):
        entry = high2
        stop_loss = entry - 1.5 * atr  # –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Å—Ç–æ–ø
        risk = entry - stop_loss
        take_profit = entry + (risk * 2)
        print(f"ScoB LONG pattern detected at {time_str}")
        return {
            "title": "long",
            "time": time_str,
            "entry": round(entry, 2),
            "stop_loss": round(stop_loss, 2),
            "take_profit": round(take_profit, 2),
        }

    # SHORT: ScoB up + close below low2  
    elif (high2 > high1 and close2 < high1 and close3 < low2):
        entry = low2
        stop_loss = entry + 1.5 * atr  # –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Å—Ç–æ–ø
        risk = stop_loss - entry
        take_profit = entry - (risk * 2)
        print(f"ScoB SHORT pattern detected at {time_str}")
        return {
            "title": "short",
            "time": time_str,
            "entry": round(entry, 2),
            "stop_loss": round(stop_loss, 2),
            "take_profit": round(take_profit, 2),
        }

    print(f"No ScoB pattern found at {time_str}")
    return None
===== ./config.py =====
# config.py
SYMBOL = "ETH/USDT:USDT"
TF = "5m" 
CAPITAL = 1000
RISK_PERCENT = 1

TELEGRAM_BOT_TOKEN = "8436652130:AAF6On0GJtRHfMZyqD3mpM57eXZfWofJeng"
TELEGRAM_CHAT_ID = "317217451"

CANDLES_NEEDED = 3
===== ./telegram.py =====
# telegram.py
import json
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, SYMBOL, TF, CAPITAL, RISK_PERCENT
from utils import calculate_position

def send_telegram_message(title, time_str, entry, stop_loss, take_profit):
    """
    Send a message to Telegram.
    If entry and stop_loss are set, include position info.
    """
    if entry and stop_loss:
        size, position_info = calculate_position(float(entry), float(stop_loss))
        message = f"""scob {title}
{time_str}
entry: {entry}
stop: {stop_loss}
tp: {take_profit}

{position_info}"""
        
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': 'BUY LIMIT', 'callback_data': f'BUY_LIMIT:{entry}'},
                    {'text': 'SELL LIMIT', 'callback_data': f'SELL_LIMIT:{entry}'}
                ],
                [
                    {'text': 'BUY MARKET', 'callback_data': 'BUY_MARKET'},
                    {'text': 'SELL MARKET', 'callback_data': 'SELL_MARKET'}
                ]
            ]
        }
    else:
        # –ü—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (High/Low break –∏ –¥—Ä—É–≥–∏–µ)
        message = take_profit
        keyboard = None
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': message,
            'parse_mode': 'HTML',
            'reply_markup': json.dumps(keyboard) if keyboard else None
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def send_startup_message():
    message = f"started\n{SYMBOL}\n{TF}\n{CAPITAL} USDT\n{RISK_PERCENT}%"
    send_telegram_message("startup", "", "", "", message)

def send_error_message(error):
    message = f"Bot error: {error}"
    send_telegram_message("error", "", "", "", message)

def set_webhook():
    url = "http://194.87.238.84:5000/webhook"
    try:
        response = requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setWebhook",
            data={"url": url}
        )
        print(f"Webhook set: {response.status_code}")
    except Exception as e:
        print(f"Error setting webhook: {e}")
===== ./event_bus.py =====
subscribers = {}

def subscribe(event_type, callback):
    if event_type not in subscribers:
        subscribers[event_type] = []
    subscribers[event_type].append(callback)

def publish(event_type, data):
    if event_type in subscribers:
        for callback in subscribers[event_type]:
            callback(data)
===== ./utils.py =====
# utils.py
from config import CAPITAL, RISK_PERCENT

def calculate_position(entry_price, stop_loss_price):
    """Calculate position size based on risk management"""
    risk_amount = CAPITAL * (RISK_PERCENT / 100)
    price_diff = abs(entry_price - stop_loss_price)
    
    if price_diff == 0:
        raise ValueError("Stop-loss cannot be zero")
    
    size = risk_amount / price_diff
    
    position_info = f"""Amount: {CAPITAL} USDT
Risk: {RISK_PERCENT}% = {risk_amount:.2f} USDT
Position size: {size:.4f} ETH"""
    
    print(position_info)
    return size, position_info
===== ./README.md =====
# scbt===== ./exchange.py =====
# exchange.py
import ccxt
from config import SYMBOL, TF

# Exchange connection
ex = ccxt.okx({
    "enableRateLimit": True,
    "options": {"defaultType": "swap"}
})

def fetch_candles(limit=3):
    """Fetch candles from exchange - returns list instead of DataFrame"""
    try:
        ohlcv = ex.fetch_ohlcv(SYMBOL, TF, limit=limit)
        return ohlcv  # [[timestamp, open, high, low, close, volume], ...]
    except Exception as e:
        print(f"Error fetching data: {e}")
        return []

def check_connection():
    """Check exchange connection"""
    try:
        markets = ex.load_markets()
        print("OKX exchange connected successfully")
        return True
    except Exception as e:
        print(f"Exchange connection error: {e}")
        return False