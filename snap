

===== callback_handler.py =====


# callback_handler.py
from event_bus import publish
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
fvg_search_active = False

def send_telegram_simple_message(text):
    """–ü—Ä–æ—Å—Ç–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram"""
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': text,
            'parse_mode': 'HTML'
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def handle_callback(query_data):
    global fvg_search_active
    
    print("CALLBACK_HANDLER: Received callback:", query_data)
    
    if query_data == "TOGGLE_FVG_SEARCH":
        # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        fvg_search_active = not fvg_search_active
        
        if fvg_search_active:
            print("üéØ FVG SEARCH ACTIVATED")
            send_telegram_simple_message("üéØ FVG SEARCH ACTIVATED")
            publish("BUTTON_CLICK", {"action": "FVG_SEARCH_ON"})
        else:
            print("‚èπÔ∏è FVG SEARCH DEACTIVATED")  
            send_telegram_simple_message("‚èπÔ∏è FVG SEARCH DEACTIVATED")
            publish("BUTTON_CLICK", {"action": "FVG_SEARCH_OFF"})
        
    else:
        # –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ (BALANCE –∏ –¥—Ä—É–≥–∏–µ)
        publish("BUTTON_CLICK", {"action": query_data})

===== config.py =====


# config.py
import os
from dotenv import load_dotenv

load_dotenv()

SYMBOL = "BTC/USDT:USDT"
TF = "1m"
CAPITAL = 500
RISK_PERCENT = 1

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

OKX_API_KEY = os.getenv("OKX_API_KEY")
OKX_SECRET_KEY = os.getenv("OKX_SECRET_KEY")
OKX_PASSPHRASE = os.getenv("OKX_PASSPHRASE")

CANDLES_NEEDED = 3

def check_env_variables():
    required_vars = {
        "TELEGRAM_BOT_TOKEN": TELEGRAM_BOT_TOKEN,
        "TELEGRAM_CHAT_ID": TELEGRAM_CHAT_ID,
        "OKX_API_KEY": OKX_API_KEY,
        "OKX_SECRET_KEY": OKX_SECRET_KEY,
        "OKX_PASSPHRASE": OKX_PASSPHRASE
    }
    
    missing_vars = []
    for name, value in required_vars.items():
        if not value:
            missing_vars.append(name)
    
    if missing_vars:
        print(f"–û—à–∏–±–∫–∞: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}")
        return False
    
    print("–í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
    return True


===== event_bus.py =====


subscribers = {}

def subscribe(event_type, callback):
    if event_type not in subscribers:
        subscribers[event_type] = []
    subscribers[event_type].append(callback)

def publish(event_type, data):
    if event_type in subscribers:
        for callback in subscribers[event_type]:
            callback(data)


===== exchange.py =====


# exchange.py
import ccxt
from config import SYMBOL, TF, OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE

_exchange_instance = None

def create_exchange():
    """–°–æ–∑–¥–∞–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç –±–∏—Ä–∂–∏"""
    if not all([OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE]):
        raise Exception("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è OKX. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª .env")
    
    return ccxt.okx({
        "apiKey": OKX_API_KEY,
        "secret": OKX_SECRET_KEY,
        "password": OKX_PASSPHRASE,
        "enableRateLimit": True,
        "options": {"defaultType": "swap"}
    })

def get_exchange():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–∏—Ä–∂–∏"""
    global _exchange_instance
    if _exchange_instance is None:
        _exchange_instance = create_exchange()
        print("OKX exchange instance created")
    return _exchange_instance

def fetch_candles_tf(symbol, timeframe, limit=1):
    """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π"""
    try:
        ex = get_exchange()
        ohlcv = ex.fetch_ohlcv(symbol, timeframe, limit=limit)
        return ohlcv
    except Exception as e:
        print(f"Error fetching {timeframe} candles for {symbol}: {e}")
        return None

def check_connection():
    """Check exchange connection"""
    try:
        ex = get_exchange()
        markets = ex.load_markets()
        print("OKX exchange connected successfully")
        return True
    except Exception as e:
        print(f"Exchange connection error: {e}")
        return False

def place_order(action, price, amount=0.001):
    """–†–µ–∞–ª—å–Ω–∞—è –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞"""
    try:
        ex = get_exchange()
        side = "buy" if action.upper() == "BUY" else "sell"
        order = ex.create_limit_order(SYMBOL, side, amount, price)
        print(f"Order placed: {order}")
        return order
    except Exception as e:
        print(f"Order error: {e}")
        return None


===== fvg_detector.py =====


# fvg_detector.py
from exchange import fetch_candles_tf
from config import SYMBOL

reported_fvg = {}

def detect_fvg():
    """–û–±–Ω–∞—Ä—É–∂–∏—Ç—å FVG –Ω–∞ 1M —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ - –û–°–ù–û–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø"""
    try:
        candles = fetch_candles_tf(SYMBOL, "1m", 4)
        if len(candles) < 4:
            return None
        
        candle1 = candles[1]  # –°–≤–µ—á–∞ –ø–æ—Å–ª–µ —Ä–∞–∑—Ä—ã–≤–∞
        candle2 = candles[2]  # –°–≤–µ—á–∞ —Ä–∞–∑—Ä—ã–≤–∞
        candle3 = candles[3]  # –°–≤–µ—á–∞ –¥–æ —Ä–∞–∑—Ä—ã–≤–∞
        
        # –ú–ï–î–í–ï–ñ–ò–ô FVG: low —Å–≤–µ—á–∏ 1 > high —Å–≤–µ—á–∏ 3
        if candle1[3] > candle3[2]:
            fvg_type = "BEAR_FVG"
            top = candle1[3]
            bottom = candle3[2]
            print(f"DEBUG: üêª TRUE BEAR FVG DETECTED: {bottom} - {top}")
            print(f"DEBUG: Candle1 Low: {candle1[3]}, Candle3 High: {candle3[2]}")
        
        # –ë–´–ß–ò–ô FVG: high —Å–≤–µ—á–∏ 1 < low —Å–≤–µ—á–∏ 3  
        elif candle1[2] < candle3[3]:
            fvg_type = "BULL_FVG"
            top = candle3[3]
            bottom = candle1[2]
            print(f"DEBUG: üêÇ TRUE BULL FVG DETECTED: {bottom} - {top}")
            print(f"DEBUG: Candle1 High: {candle1[2]}, Candle3 Low: {candle3[3]}")
        
        else:
            print("DEBUG: No FVG pattern found")
            return None
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ —Å–æ–æ–±—â–∞–ª–∏ –ª–∏ —É–∂–µ –æ–± —ç—Ç–æ–º FVG
        fvg_key = f"{fvg_type}_{top}_{bottom}"
        if fvg_key not in reported_fvg:
            reported_fvg[fvg_key] = True
            return {
                "type": fvg_type,
                "top": top,
                "bottom": bottom,
                "direction": "BEAR" if fvg_type == "BEAR_FVG" else "BULL"
            }
        
        print(f"DEBUG: FVG already reported: {fvg_key}")
        return None
        
    except Exception as e:
        print(f"FVG detection error: {e}")
        return None

def monitor_fvg_independent():
    """–ù–ï–ó–ê–í–ò–°–ò–ú–´–ô –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ FVG - –¥–ª—è –¥–µ–±–∞–≥–∞"""
    try:
        print("\n" + "="*50)
        print("üîç INDEPENDENT FVG MONITORING")
        print("="*50)
        
        candles = fetch_candles_tf(SYMBOL, "1m", 4)
        if len(candles) < 4:
            print("DEBUG: Not enough candles for FVG monitoring")
            return
        
        print(f"DEBUG: Last 4 candles:")
        for i, candle in enumerate(candles):
            timestamp = candle[0]
            open_price = candle[1]
            high = candle[2]
            low = candle[3]
            close = candle[4]
            print(f"  Candle {i}: O:{open_price} H:{high} L:{low} C:{close}")
        
        candle1 = candles[1]  # –°–≤–µ—á–∞ –ø–æ—Å–ª–µ —Ä–∞–∑—Ä—ã–≤–∞
        candle2 = candles[2]  # –°–≤–µ—á–∞ —Ä–∞–∑—Ä—ã–≤–∞
        candle3 = candles[3]  # –°–≤–µ—á–∞ –¥–æ —Ä–∞–∑—Ä—ã–≤–∞
        
        print(f"DEBUG: Checking FVG conditions:")
        print(f"  Bear FVG: Candle1 Low ({candle1[3]}) > Candle3 High ({candle3[2]}) = {candle1[3] > candle3[2]}")
        print(f"  Bull FVG: Candle1 High ({candle1[2]}) < Candle3 Low ({candle3[3]}) = {candle1[2] < candle3[3]}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è
        if candle1[3] > candle3[2]:
            print("üéØ TRUE BEAR FVG FOUND!")
            return "BEAR_FVG"
        elif candle1[2] < candle3[3]:
            print("üéØ TRUE BULL FVG FOUND!")
            return "BULL_FVG"
        else:
            print("‚ùå NO FVG FOUND")
            return None
            
    except Exception as e:
        print(f"FVG monitoring error: {e}")
        return None

===== levels.py =====


# levels.py
from exchange import fetch_candles_tf
from config import SYMBOL

reported_breakouts = {}  # –•—Ä–∞–Ω–∏–º –ü–†–û–ë–ò–¢–´–ï —É—Ä–æ–≤–Ω–∏
last_4h_timestamp = None
last_1h_timestamp = None

def find_current_levels():
    """–ù–∞–π—Ç–∏ —É—Ä–æ–≤–Ω–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–≤–µ—á–µ–π 4H –∏ 1H"""
    levels = []

    try:
        # 4H –ø—Ä–µ–¥—ã–¥—É—â–∞—è –∑–∞–∫—Ä—ã—Ç–∞—è —Å–≤–µ—á–∞
        c4 = fetch_candles_tf(SYMBOL, "4h", 2)
        if c4 and len(c4) >= 2:
            prev_candle = c4[-2]
            timestamp = prev_candle[0]
            levels.append(("4H_HIGH", prev_candle[2], timestamp))
            levels.append(("4H_LOW", prev_candle[3], timestamp))
            print(f"DEBUG: 4H Levels - HIGH: {prev_candle[2]}, LOW: {prev_candle[3]}")

        # 1H –ø—Ä–µ–¥—ã–¥—É—â–∞—è –∑–∞–∫—Ä—ã—Ç–∞—è —Å–≤–µ—á–∞
        c1 = fetch_candles_tf(SYMBOL, "1h", 2)
        if c1 and len(c1) >= 2:
            prev_candle = c1[-2]
            timestamp = prev_candle[0]
            levels.append(("1H_HIGH", prev_candle[2], timestamp))
            levels.append(("1H_LOW", prev_candle[3], timestamp))
            print(f"DEBUG: 1H Levels - HIGH: {prev_candle[2]}, LOW: {prev_candle[3]}")

        print(f"DEBUG: Total levels to monitor: {len(levels)}")
        return levels
        
    except Exception as e:
        print(f"ERROR in find_current_levels: {e}")
        return []

def check_level_breakout(current_price, levels):
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ü–†–û–ë–û–ô —É—Ä–æ–≤–Ω–µ–π"""
    print(f"DEBUG: Checking BREAKOUTS - Current price: {current_price}")
    
    for level_type, level_price, level_timestamp in levels:
        key = f"{level_type}_{level_price}"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±—ã–ª –ª–∏ —É–∂–µ –ø—Ä–æ–±–æ–π —ç—Ç–æ–≥–æ —É—Ä–æ–≤–Ω—è
        if key in reported_breakouts:
            if reported_breakouts[key] != level_timestamp:
                del reported_breakouts[key]  # –°–±—Ä–æ—Å –ø—Ä–∏ —Å–º–µ–Ω–µ —Å–≤–µ—á–∏
            else:
                continue  # –£–∂–µ —Å–æ–æ–±—â–∞–ª–∏ –æ –ø—Ä–æ–±–æ–µ
        
        # –ü–†–û–ë–û–ô –í–í–ï–†–•: —Ü–µ–Ω–∞ > HIGH —É—Ä–æ–≤–Ω—è
        if level_type.endswith('HIGH') and current_price > level_price:
            print(f"DEBUG: üü¢ BREAKOUT UP - {level_type} {current_price} > {level_price}")
            reported_breakouts[key] = level_timestamp
            return {
                "type": level_type,
                "price": level_price,
                "direction": "UP",
                "current": current_price
            }
        
        # –ü–†–û–ë–û–ô –í–ù–ò–ó: —Ü–µ–Ω–∞ < LOW —É—Ä–æ–≤–Ω—è  
        elif level_type.endswith('LOW') and current_price < level_price:
            print(f"DEBUG: üî¥ BREAKOUT DOWN - {level_type} {current_price} < {level_price}")
            reported_breakouts[key] = level_timestamp
            return {
                "type": level_type,
                "price": level_price, 
                "direction": "DOWN", 
                "current": current_price
            }
    
    print("DEBUG: No breakouts detected")
    return None

def check_new_candles():
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–º–µ–Ω—É —Å–≤–µ—á–µ–π 4H –∏ 1H"""
    global last_4h_timestamp, last_1h_timestamp
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º 4H —Å–≤–µ—á—É
        c4 = fetch_candles_tf(SYMBOL, "4h", 1)
        if c4:
            current_4h_timestamp = c4[0][0]
            if last_4h_timestamp is None:
                last_4h_timestamp = current_4h_timestamp
            elif current_4h_timestamp != last_4h_timestamp:
                last_4h_timestamp = current_4h_timestamp
                return "4H_NEW"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º 1H —Å–≤–µ—á—É
        c1 = fetch_candles_tf(SYMBOL, "1h", 1)
        if c1:
            current_1h_timestamp = c1[0][0]
            if last_1h_timestamp is None:
                last_1h_timestamp = current_1h_timestamp
            elif current_1h_timestamp != last_1h_timestamp:
                last_1h_timestamp = current_1h_timestamp
                return "1H_NEW"
                
        return None
        
    except Exception as e:
        print(f"Error checking new candles: {e}")
        return None

def check_smc_levels():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Ä–æ–≤–Ω–µ–π - –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–†–û–ë–û–ô"""
    try:
        print("DEBUG: === BREAKOUT CHECK STARTED ===")
        current_candle = fetch_candles_tf(SYMBOL, "1m", 1)
        if not current_candle:
            print("DEBUG: No 1m candle data")
            return None

        current_price = current_candle[0][4]
        print(f"DEBUG: Current 1m price: {current_price}")
        
        levels = find_current_levels()
        result = check_level_breakout(current_price, levels)  # ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–†–û–ë–û–ô
        
        if result:
            print(f"DEBUG: üö® BREAKOUT SIGNAL: {result}")
        else:
            print("DEBUG: No breakout signal")
            
        print("DEBUG: === BREAKOUT CHECK FINISHED ===")
        return result
        
    except Exception as e:
        print(f"ERROR in check_smc_levels: {e}")
        return None

===== main.py =====


# main.py
import order_manager
import time
import threading
import gc
import requests
from exchange import check_connection
from telegram import send_startup_message, send_telegram_message, send_error_message
from callback_handler import handle_callback, fvg_search_active
from config import TELEGRAM_BOT_TOKEN, check_env_variables
from levels import check_smc_levels, check_new_candles, find_current_levels
from fvg_detector import detect_fvg

# –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ main.py –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π...

def get_updates(offset=None):
    """Get updates from Telegram via polling"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'timeout': 30, 'offset': offset}
    try:
        response = requests.get(url, params=params, timeout=35)
        return response.json()
    except:
        return {'result': []}

def process_updates():
    """Process Telegram updates in background"""
    last_update_id = None
    print("Starting Telegram updates polling...")

    while True:
        try:
            updates = get_updates(last_update_id)
            if updates.get('result'):
                for update in updates['result']:
                    if 'callback_query' in update:
                        callback_data = update['callback_query']['data']
                        print(f"Received callback: {callback_data}")
                        handle_callback(callback_data)
                    last_update_id = update['update_id'] + 1
            time.sleep(1)
        except Exception as e:
            print(f"Updates error: {e}")
            time.sleep(5)

def main():
    print("Starting SMC Levels Bot...")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
    if not check_env_variables():
        print("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        return
    
    print("Monitoring 4H/1H levels + FVG...")

    send_startup_message()

    if not check_connection():
        return

    polling_thread = threading.Thread(target=process_updates, daemon=True)
    polling_thread.start()
    print("Telegram polling started")

    last_signal_time = 0
    last_candle_check_time = 0
    last_levels_check_time = 0
    last_fvg_check_time = 0

    print("üöÄ Bot started successfully. Monitoring levels every 60 seconds...")

    while True:
        try:
            current_time = int(time.time() * 1000)
            
            # ‚úÖ –†–£–ß–ù–û–ô –ü–û–ò–°–ö FVG (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω)
            if fvg_search_active and current_time - last_fvg_check_time > 60000:
                print(f"üîç [{time.strftime('%H:%M:%S')}] FVG SEARCH active - checking...")
                fvg_signal = detect_fvg()
                if fvg_signal:
                    print(f"üéØ FVG found: {fvg_signal['type']}")
                    message = f"üéØ FVG Found\nType: {fvg_signal['type']}\nRange: {fvg_signal['bottom']} - {fvg_signal['top']}"
                    send_telegram_message("fvg", "", "", "", message)
                
                last_fvg_check_time = current_time
            
            # –ü–†–û–í–ï–†–Ø–ï–ú –ü–†–û–ë–û–ô –£–†–û–í–ù–ï–ô –ö–ê–ñ–î–£–Æ –ú–ò–ù–£–¢–£ (60 —Å–µ–∫—É–Ω–¥)
            if current_time - last_levels_check_time > 60000:
                print(f"\nüïí [{time.strftime('%H:%M:%S')}] Checking for breakouts...")
                signal = check_smc_levels()

                if signal:
                    if current_time - last_signal_time > 60000:  # –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ø–∞–º–∞
                        print(f"üì® Level breakout detected: {signal}")
                        
                        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—Ä–æ–±–æ–µ
                        level_type = signal['type']
                        direction = signal['direction']
                        message = f"üéØ Level Breakout\n{level_type.replace('_', ' ')} {direction}\nLevel: {signal['price']}\nCurrent: {signal['current']}"
                        
                        send_telegram_message("breakout", "", "", "", message)
                        last_signal_time = current_time
                    else:
                        print("‚è≥ Signal skipped (spam protection - 60s cooldown)")
                else:
                    print("üìä No breakout signals detected")
                
                last_levels_check_time = current_time

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–º–µ–Ω—É —Å–≤–µ—á–µ–π –∫–∞–∂–¥—ã–µ 60 —Å–µ–∫—É–Ω–¥
            if current_time - last_candle_check_time > 60000:
                new_candle = check_new_candles()
                if new_candle:
                    print(f"üîÑ New candle detected: {new_candle}")
                    
                    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —É—Ä–æ–≤–Ω–∏
                    levels = find_current_levels()
                    
                    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —É—Ä–æ–≤–Ω–µ–π
                    levels_text = ""
                    levels_4h = []
                    levels_1h = []
                    
                    for level_type, level_price, _ in levels:
                        if level_type.startswith('4H'):
                            levels_4h.append((level_type, level_price))
                        else:
                            levels_1h.append((level_type, level_price))
                    
                    # –£—Ä–æ–≤–Ω–∏ 4H
                    for level_type, level_price in levels_4h:
                        tf, l_type = level_type.split('_')
                        level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
                        levels_text += f"{level_display}\n"
                    
                    # –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –º–µ–∂–¥—É —É—Ä–æ–≤–Ω—è–º–∏
                    levels_text += "\n"
                    
                    # –£—Ä–æ–≤–Ω–∏ 1H
                    for level_type, level_price in levels_1h:
                        tf, l_type = level_type.split('_')
                        level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
                        levels_text += f"{level_display}\n"
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤—ã—Ö —É—Ä–æ–≤–Ω—è—Ö
                    timeframe = new_candle.replace('_NEW', '').lower()
                    message = f"üîÑ New {timeframe} Candle\n\nüìä Updated Levels:\n{levels_text}"
                    send_telegram_message("update", "", "", "", message)
                    print(f"üì® Sent levels update for {timeframe}")
                
                last_candle_check_time = current_time

            gc.collect()
            time.sleep(6)  # –û—Å–Ω–æ–≤–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —Ü–∏–∫–ª–∞

        except KeyboardInterrupt:
            print("\nüõë Bot stopped manually")
            break
        except Exception as e:
            print(f"‚ùå Bot error: {e}")
            send_error_message(str(e))
            time.sleep(30)

if __name__ == "__main__":
    main()

===== telegram.py =====


# telegram.py
import json
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, SYMBOL

def send_telegram_message(title, time_str, entry, stop_loss, take_profit, keyboard=None):
    """
    Send a message to Telegram.
    """
    message = take_profit  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
    
    # –ï—Å–ª–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é
    if keyboard is None:
        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∑–¥–µ—Å—å —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞
        from callback_handler import fvg_search_active
        
        # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ FVG SEARCH
        button_text = "üîç FVG SEARCH" if not fvg_search_active else "‚èπÔ∏è FVG SEARCH"
        
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': button_text, 'callback_data': 'TOGGLE_FVG_SEARCH'}
                ]
            ]
        }
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': message,
            'parse_mode': 'HTML',
            'reply_markup': json.dumps(keyboard) if keyboard else None
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def send_startup_message():
    try:
        from exchange import get_exchange
        from levels import find_current_levels
        
        ex = get_exchange()
        balance = ex.fetch_balance()
        usdt_balance = balance['total'].get('USDT', 0)
        rounded_balance = round(usdt_balance, 1)
        
        levels = find_current_levels()
        
        levels_4h = []
        levels_1h = []
        
        for level_type, level_price, _ in levels:
            if level_type.startswith('4H'):
                levels_4h.append((level_type, level_price))
            else:
                levels_1h.append((level_type, level_price))
        
        levels_text = ""
        
        for level_type, level_price in levels_4h:
            tf, l_type = level_type.split('_')
            level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
            levels_text += f"{level_display}\n"
        
        levels_text += "\n"
        
        for level_type, level_price in levels_1h:
            tf, l_type = level_type.split('_')
            level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
            levels_text += f"{level_display}\n"
        
        message = f"""üöÄ Started
{SYMBOL}

üìä Current Levels
{levels_text}"""
        
        send_telegram_message("startup", "", "", "", message)
    except Exception as e:
        message = f"""üöÄ Started
{SYMBOL}

Levels: error - {e}"""
        send_telegram_message("startup", "", "", "", message)

def send_error_message(error):
    message = f"Bot error: {error}"
    send_telegram_message("error", "", "", "", message)

===== test_api.py =====


# test_api.py
from exchange import create_exchange
ex = create_exchange()
try:
    candles = ex.fetch_ohlcv("BTC/USDT:USDT", "1m", limit=1)
    print("API —Ä–∞–±–æ—Ç–∞–µ—Ç:", candles[0] if candles else "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
except Exception as e:
    print("–û—à–∏–±–∫–∞ API:", e)
