

===== callback_handler.py =====


# callback_handler.py
from event_bus import publish
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
fvg_search_active = False

def send_telegram_simple_message(text):
    """–ü—Ä–æ—Å—Ç–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram"""
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': text,
            'parse_mode': 'HTML'
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def handle_callback(query_data):
    global fvg_search_active
    
    print("CALLBACK_HANDLER: Received callback:", query_data)
    
    if query_data == "TOGGLE_FVG_SEARCH":
        # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        fvg_search_active = not fvg_search_active
        
        if fvg_search_active:
            print("üéØ FVG SEARCH ACTIVATED")
            send_telegram_simple_message("üéØ FVG SEARCH ACTIVATED")
        else:
            print("‚èπÔ∏è FVG SEARCH DEACTIVATED")  
            send_telegram_simple_message("‚èπÔ∏è FVG SEARCH DEACTIVATED")
        
    else:
        # –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
        publish("BUTTON_CLICK", {"action": query_data})

===== config.py =====


# config.py
import os
from dotenv import load_dotenv

load_dotenv()

SYMBOL = "BTC/USDT:USDT"
TF = "1m"
CAPITAL = 500
RISK_PERCENT = 1

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

OKX_API_KEY = os.getenv("OKX_API_KEY")
OKX_SECRET_KEY = os.getenv("OKX_SECRET_KEY")
OKX_PASSPHRASE = os.getenv("OKX_PASSPHRASE")

CANDLES_NEEDED = 3

def check_env_variables():
    required_vars = {
        "TELEGRAM_BOT_TOKEN": TELEGRAM_BOT_TOKEN,
        "TELEGRAM_CHAT_ID": TELEGRAM_CHAT_ID,
        "OKX_API_KEY": OKX_API_KEY,
        "OKX_SECRET_KEY": OKX_SECRET_KEY,
        "OKX_PASSPHRASE": OKX_PASSPHRASE
    }
    
    missing_vars = []
    for name, value in required_vars.items():
        if not value:
            missing_vars.append(name)
    
    if missing_vars:
        print(f"–û—à–∏–±–∫–∞: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}")
        return False
    
    print("–í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
    return True


===== event_bus.py =====


subscribers = {}

def subscribe(event_type, callback):
    if event_type not in subscribers:
        subscribers[event_type] = []
    subscribers[event_type].append(callback)

def publish(event_type, data):
    if event_type in subscribers:
        for callback in subscribers[event_type]:
            callback(data)


===== exchange.py =====


# exchange.py
import ccxt
from config import SYMBOL, TF, OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE

_exchange_instance = None

def create_exchange():
    """–°–æ–∑–¥–∞–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç –±–∏—Ä–∂–∏"""
    if not all([OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE]):
        raise Exception("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è OKX. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª .env")
    
    return ccxt.okx({
        "apiKey": OKX_API_KEY,
        "secret": OKX_SECRET_KEY,
        "password": OKX_PASSPHRASE,
        "enableRateLimit": True,
        "options": {"defaultType": "swap"}
    })

def get_exchange():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–∏—Ä–∂–∏"""
    global _exchange_instance
    if _exchange_instance is None:
        _exchange_instance = create_exchange()
        print("OKX exchange instance created")
    return _exchange_instance

def fetch_candles_tf(symbol, timeframe, limit=1):
    """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π"""
    try:
        ex = get_exchange()
        ohlcv = ex.fetch_ohlcv(symbol, timeframe, limit=limit)
        return ohlcv
    except Exception as e:
        print(f"Error fetching {timeframe} candles for {symbol}: {e}")
        return None

def check_connection():
    """Check exchange connection"""
    try:
        ex = get_exchange()
        markets = ex.load_markets()
        print("OKX exchange connected successfully")
        return True
    except Exception as e:
        print(f"Exchange connection error: {e}")
        return False

def place_order(action, price, amount=0.001):
    """–†–µ–∞–ª—å–Ω–∞—è –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞"""
    try:
        ex = get_exchange()
        side = "buy" if action.upper() == "BUY" else "sell"
        order = ex.create_limit_order(SYMBOL, side, amount, price)
        print(f"Order placed: {order}")
        return order
    except Exception as e:
        print(f"Order error: {e}")
        return None


===== fvg_detector.py =====


# fvg_detector.py
from exchange import fetch_candles_tf
from config import SYMBOL

reported_fvg = {}

def detect_fvg():
    """
    –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ FVG —Å—Ç—Ä–æ–≥–æ –ü–û –ó–ê–ö–†–´–¢–´–ú —Å–≤–µ—á–∞–º.
    –ë–µ—Ä—ë–º 4 —Å–≤–µ—á–∏, —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –∏—Å–∫–ª—é—á–∏—Ç—å —Ç–µ–∫—É—â—É—é (–Ω–µ–∑–∞–∫—Ä—ã—Ç—É—é).
    –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ç—Ä–∏ –∑–∞–∫—Ä—ã—Ç—ã–µ:
        first  = n-3
        second = n-2
        third  = n-1 (—Ç–∞, –∫–æ—Ç–æ—Ä–∞—è —Ç–æ–ª—å–∫–æ —á—Ç–æ –∑–∞–∫—Ä—ã–ª–∞—Å—å)
    """
    try:
        candles = fetch_candles_tf(SYMBOL, "1m", 4)  # –ë–µ—Ä—ë–º 4 —Å–≤–µ—á–∏
        if not candles or len(candles) < 4:
            return None

        # –í—Å–µ —Ç—Ä–∏ —Å–≤–µ—á–∏ ‚Äî –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–∫—Ä—ã—Ç—ã–µ
        first  = candles[-4]   # n-3
        second = candles[-3]   # n-2
        third  = candles[-2]   # n-1

        # –ë–´–ß–ò–ô FVG (Fair Value Gap –≤–≤–µ—Ä—Ö)
        bull_fvg = (
            third[3] > first[2] and      # low(n-1) > high(n-3)
            second[3] <= first[2] and    # low(n-2) <= high(n-3)
            second[2] >= third[3]        # high(n-2) >= low(n-1)
        )

        # –ú–ï–î–í–ï–ñ–ò–ô FVG (Fair Value Gap –≤–Ω–∏–∑)
        bear_fvg = (
            third[2] < first[3] and      # high(n-1) < low(n-3)
            third[2] >= second[3] and    # high(n-1) >= low(n-2)
            second[2] >= first[3]        # high(n-2) >= low(n-3)
        )

        if not bull_fvg and not bear_fvg:
            return None

        if bull_fvg:
            fvg_type = "BULL_FVG"
            top = third[3]      # low(n-1)
            bottom = first[2]   # high(n-3)
        else:
            fvg_type = "BEAR_FVG"
            top = first[3]      # low(n-3)
            bottom = third[2]   # high(n-1)

        key = f"{fvg_type}_{top}_{bottom}"

        if key not in reported_fvg:
            reported_fvg[key] = True
            return {
                "type": fvg_type,
                "top": top,
                "bottom": bottom,
                "direction": "BULL" if fvg_type == "BULL_FVG" else "BEAR"
            }

        return None

    except Exception as e:
        print(f"FVG detection error: {e}")
        return None


===== levels.py =====


# levels.py
from exchange import fetch_candles_tf
from config import SYMBOL

reported_breakouts = {}  # –•—Ä–∞–Ω–∏–º –ü–†–û–ë–ò–¢–´–ï —É—Ä–æ–≤–Ω–∏
last_4h_timestamp = None

def find_current_levels():
    """–ù–∞–π—Ç–∏ —É—Ä–æ–≤–Ω–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–≤–µ—á–µ–π 4H"""
    levels = []

    try:
        # 4H –ø—Ä–µ–¥—ã–¥—É—â–∞—è –∑–∞–∫—Ä—ã—Ç–∞—è —Å–≤–µ—á–∞
        c4 = fetch_candles_tf(SYMBOL, "4h", 2)
        if c4 and len(c4) >= 2:
            prev_candle = c4[-2]
            timestamp = prev_candle[0]
            levels.append(("4H_HIGH", prev_candle[2], timestamp))
            levels.append(("4H_LOW", prev_candle[3], timestamp))
            print(f"DEBUG: 4H Levels - HIGH: {prev_candle[2]}, LOW: {prev_candle[3]}")

        print(f"DEBUG: Total levels to monitor: {len(levels)}")
        return levels
        
    except Exception as e:
        print(f"ERROR in find_current_levels: {e}")
        return []

def check_level_breakout(current_price, levels):
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ü–†–û–ë–û–ô —É—Ä–æ–≤–Ω–µ–π"""
    print(f"DEBUG: Checking BREAKOUTS - Current price: {current_price}")
    
    for level_type, level_price, level_timestamp in levels:
        key = f"{level_type}_{level_price}"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±—ã–ª –ª–∏ —É–∂–µ –ø—Ä–æ–±–æ–π —ç—Ç–æ–≥–æ —É—Ä–æ–≤–Ω—è
        if key in reported_breakouts:
            if reported_breakouts[key] != level_timestamp:
                del reported_breakouts[key]  # –°–±—Ä–æ—Å –ø—Ä–∏ —Å–º–µ–Ω–µ —Å–≤–µ—á–∏
            else:
                continue  # –£–∂–µ —Å–æ–æ–±—â–∞–ª–∏ –æ –ø—Ä–æ–±–æ–µ
        
        # –ü–†–û–ë–û–ô –í–í–ï–†–•: —Ü–µ–Ω–∞ > HIGH —É—Ä–æ–≤–Ω—è
        if level_type.endswith('HIGH') and current_price > level_price:
            print(f"DEBUG: üü¢ BREAKOUT UP - {level_type} {current_price} > {level_price}")
            reported_breakouts[key] = level_timestamp
            return {
                "type": level_type,
                "price": level_price,
                "direction": "UP",
                "current": current_price
            }
        
        # –ü–†–û–ë–û–ô –í–ù–ò–ó: —Ü–µ–Ω–∞ < LOW —É—Ä–æ–≤–Ω—è  
        elif level_type.endswith('LOW') and current_price < level_price:
            print(f"DEBUG: üî¥ BREAKOUT DOWN - {level_type} {current_price} < {level_price}")
            reported_breakouts[key] = level_timestamp
            return {
                "type": level_type,
                "price": level_price, 
                "direction": "DOWN", 
                "current": current_price
            }
    
    print("DEBUG: No breakouts detected")
    return None

def check_new_candles():
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–º–µ–Ω—É —Å–≤–µ—á–µ–π 4H"""
    global last_4h_timestamp
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º 4H —Å–≤–µ—á—É
        c4 = fetch_candles_tf(SYMBOL, "4h", 1)
        if c4:
            current_4h_timestamp = c4[0][0]
            if last_4h_timestamp is None:
                last_4h_timestamp = current_4h_timestamp
            elif current_4h_timestamp != last_4h_timestamp:
                last_4h_timestamp = current_4h_timestamp
                return "4H_NEW"
                
        return None
        
    except Exception as e:
        print(f"Error checking new candles: {e}")
        return None

def check_smc_levels():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Ä–æ–≤–Ω–µ–π - –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–†–û–ë–û–ô"""
    try:
        print("DEBUG: === BREAKOUT CHECK STARTED ===")
        current_candle = fetch_candles_tf(SYMBOL, "1m", 1)
        if not current_candle:
            print("DEBUG: No 1m candle data")
            return None

        current_price = current_candle[0][4]
        print(f"DEBUG: Current 1m price: {current_price}")
        
        levels = find_current_levels()
        result = check_level_breakout(current_price, levels)  # ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –ü–†–û–ë–û–ô
        
        if result:
            print(f"DEBUG: üö® BREAKOUT SIGNAL: {result}")
        else:
            print("DEBUG: No breakout signal")
            
        print("DEBUG: === BREAKOUT CHECK FINISHED ===")
        return result
        
    except Exception as e:
        print(f"ERROR in check_smc_levels: {e}")
        return None

===== main.py =====


# main.py
import time
import threading
import gc
import requests
from exchange import check_connection, fetch_candles_tf
from telegram import send_startup_message, send_telegram_message, send_error_message
from callback_handler import handle_callback
from config import TELEGRAM_BOT_TOKEN, check_env_variables, SYMBOL
from levels import check_smc_levels, check_new_candles, find_current_levels
from fvg_detector import detect_fvg


def get_updates(offset=None):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'timeout': 30, 'offset': offset}
    try:
        response = requests.get(url, params=params, timeout=35)
        return response.json()
    except:
        return {'result': []}


def process_updates():
    last_update_id = None
    print("Starting Telegram updates polling...")

    while True:
        try:
            updates = get_updates(last_update_id)
            if updates.get('result'):
                for update in updates['result']:
                    if 'callback_query' in update:
                        callback_data = update['callback_query']['data']
                        print(f"Received callback: {callback_data}")
                        handle_callback(callback_data)
                    last_update_id = update['update_id'] + 1
            time.sleep(1)
        except Exception as e:
            print(f"Updates error: {e}")
            time.sleep(5)


def main():
    print("Starting SMC Levels Bot...")

    if not check_env_variables():
        print("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        return

    print("Monitoring 4H levels + FVG search...")

    send_startup_message()

    if not check_connection():
        return

    polling_thread = threading.Thread(target=process_updates, daemon=True)
    polling_thread.start()
    print("Telegram polling started")

    last_signal_time = 0
    last_candle_check_time = 0
    last_levels_check_time = 0

    # ‚úÖ –ö–æ–Ω—Ç—Ä–æ–ª—å FVG (—á—Ç–æ–±—ã –Ω–µ –∏—Å–∫–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ –Ω–∞ —Ç–æ–π –∂–µ —Å–≤–µ—á–µ)
    last_fvg_candle = None

    print("üöÄ Bot started successfully. Working...")

    while True:
        try:
            current_time = int(time.time() * 1000)

            # ‚úÖ FVG SEARCH ‚Äî —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è 1m —Å–≤–µ—á–∏
            from callback_handler import fvg_search_active
            if fvg_search_active:
                candles = fetch_candles_tf(SYMBOL, "1m", 2)
                if candles and len(candles) >= 2:
                    last_closed_ts = candles[-2][0]

                    if last_fvg_candle != last_closed_ts:
                        last_fvg_candle = last_closed_ts

                        print("üîç FVG SEARCH: Checking closed candle...")
                        fvg_signal = detect_fvg()

                        if fvg_signal:
                            print(f"üéØ FVG FOUND: {fvg_signal}")
                            message = f"""üéØ FVG Found
Type: {fvg_signal['type']}
Range: {fvg_signal['bottom']} - {fvg_signal['top']}"""
                            send_telegram_message("fvg", "", "", "", message)
                        else:
                            print("‚ùå No FVG this candle")


            # ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ–µ–≤ —É—Ä–æ–≤–Ω–µ–π —Ä–∞–∑ –≤ 60 —Å–µ–∫
            if current_time - last_levels_check_time > 60000:
                print(f"\nüïí [{time.strftime('%H:%M:%S')}] Checking for breakouts...")
                signal = check_smc_levels()

                if signal:
                    if current_time - last_signal_time > 60000:
                        print(f"üì® Level breakout detected: {signal}")
                        # –ü–†–û–°–¢–û–ï –°–û–û–ë–©–ï–ù–ò–ï –û –ü–†–û–ë–û–ï
                        message = f"break {signal['price']}"
                        send_telegram_message("breakout", "", "", "", message)
                        last_signal_time = current_time
                    else:
                        print("‚è≥ Cooldown, skipping duplicate breakout...")
                else:
                    print("üìä No breakouts detected.")

                last_levels_check_time = current_time


            # ‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤—ã—Ö —Å–≤–µ—á–µ–π 4H
            if current_time - last_candle_check_time > 60000:
                new_candle = check_new_candles()

                if new_candle:
                    print(f"üîÑ New candle detected: {new_candle}")
                    levels = find_current_levels()

                    # –ü–†–û–°–¢–û–ï –°–û–û–ë–©–ï–ù–ò–ï –û–ë –û–ë–ù–û–í–õ–ï–ù–ò–ò –£–†–û–í–ù–ï–ô
                    levels_text = ""
                    for level_type, level_price, _ in levels:
                        if level_type.startswith('4H'):
                            tf, l_type = level_type.split('_')
                            levels_text += f"{l_type.lower()} {level_price}\n"

                    timeframe = new_candle.replace('_NEW', '').lower()
                    message = f"update {timeframe}\n{levels_text}"
                    send_telegram_message("update", "", "", "", message)

                last_candle_check_time = current_time


            gc.collect()
            time.sleep(6)

        except KeyboardInterrupt:
            print("\nüõë Bot stopped manually.")
            break
        except Exception as e:
            print(f"‚ùå Bot error: {e}")
            send_error_message(str(e))
            time.sleep(30)


if __name__ == "__main__":
    main()

===== telegram.py =====


# telegram.py
import json
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, SYMBOL

def send_telegram_message(title, time_str, entry, stop_loss, take_profit, keyboard=None):
    """
    Send a message to Telegram.
    """
    message = take_profit  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
    
    # –ï—Å–ª–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é
    if keyboard is None:
        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∑–¥–µ—Å—å —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞
        from callback_handler import fvg_search_active
        
        # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ FVG SEARCH
        button_text = "FVG SEARCH" if not fvg_search_active else "FVG SEARCH"
        
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': button_text, 'callback_data': 'TOGGLE_FVG_SEARCH'}
                ]
            ]
        }
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': message,
            'parse_mode': 'HTML',
            'reply_markup': json.dumps(keyboard) if keyboard else None
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def send_startup_message():
    try:
        from exchange import get_exchange
        from levels import find_current_levels
        
        ex = get_exchange()
        balance = ex.fetch_balance()
        usdt_balance = balance['total'].get('USDT', 0)
        rounded_balance = round(usdt_balance, 1)
        
        levels = find_current_levels()
        
        # –ò–ó–ú–ï–ù–ò–õ –§–û–†–ú–ê–¢ –°–û–û–ë–©–ï–ù–ò–Ø
        levels_text = ""
        for level_type, level_price, _ in levels:
            if level_type.startswith('4H'):
                tf, l_type = level_type.split('_')
                levels_text += f"{l_type.lower()} {level_price}\n"
        
        message = f"""{SYMBOL}
{levels_text}"""
        
        send_telegram_message("startup", "", "", "", message)
    except Exception as e:
        message = f"""{SYMBOL}
error - {e}"""
        send_telegram_message("startup", "", "", "", message)

def send_error_message(error):
    message = f"Bot error: {error}"
    send_telegram_message("error", "", "", "", message)

===== test_api.py =====


# test_api.py
from exchange import create_exchange
ex = create_exchange()
try:
    candles = ex.fetch_ohlcv("BTC/USDT:USDT", "1m", limit=1)
    print("API —Ä–∞–±–æ—Ç–∞–µ—Ç:", candles[0] if candles else "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
except Exception as e:
    print("–û—à–∏–±–∫–∞ API:", e)
