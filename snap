

===== callback_handler.py =====


# callback_handler.py
from event_bus import publish
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ —Ä—É—á–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
fvg_search_active = False

def send_telegram_simple_message(text):
    """–ü—Ä–æ—Å—Ç–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram"""
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': text,
            'parse_mode': 'HTML'
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def handle_callback(query_data):
    global fvg_search_active
    
    print("CALLBACK_HANDLER: Received callback:", query_data)
    
    if query_data == "TOGGLE_FVG_SEARCH":
        # –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        fvg_search_active = not fvg_search_active
        
        if fvg_search_active:
            print("üéØ FVG SEARCH ACTIVATED")
            send_telegram_simple_message("FVG search activated")
        else:
            print("‚èπÔ∏è FVG SEARCH DEACTIVATED")  
            send_telegram_simple_message("FVG search deactivated")
        
    else:
        # –û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
        publish("BUTTON_CLICK", {"action": query_data})

===== config.py =====


# config.py
import os
from dotenv import load_dotenv

load_dotenv()

SYMBOL = "BTC/USDT:USDT"
FVG_TF = "5m"
LEVEL_TF = "4h"

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

OKX_API_KEY = os.getenv("OKX_API_KEY")
OKX_SECRET_KEY = os.getenv("OKX_SECRET_KEY")
OKX_PASSPHRASE = os.getenv("OKX_PASSPHRASE")

CANDLES_NEEDED = 3

def check_env_variables():
    required_vars = {
        "TELEGRAM_BOT_TOKEN": TELEGRAM_BOT_TOKEN,
        "TELEGRAM_CHAT_ID": TELEGRAM_CHAT_ID,
        "OKX_API_KEY": OKX_API_KEY,
        "OKX_SECRET_KEY": OKX_SECRET_KEY,
        "OKX_PASSPHRASE": OKX_PASSPHRASE
    }
    
    missing_vars = []
    for name, value in required_vars.items():
        if not value:
            missing_vars.append(name)
    
    if missing_vars:
        print(f"–û—à–∏–±–∫–∞: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}")
        return False
    
    print("–í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
    return True


===== event_bus.py =====


subscribers = {}

def subscribe(event_type, callback):
    if event_type not in subscribers:
        subscribers[event_type] = []
    subscribers[event_type].append(callback)

def publish(event_type, data):
    if event_type in subscribers:
        for callback in subscribers[event_type]:
            callback(data)


===== exchange.py =====


# exchange.py
import ccxt
from config import SYMBOL, OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE

_exchange_instance = None

def create_exchange():
    """–°–æ–∑–¥–∞–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç –±–∏—Ä–∂–∏"""
    if not all([OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE]):
        raise Exception("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è OKX. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª .env")
    
    return ccxt.okx({
        "apiKey": OKX_API_KEY,
        "secret": OKX_SECRET_KEY,
        "password": OKX_PASSPHRASE,
        "enableRateLimit": True,
        "options": {"defaultType": "swap"}
    })

def get_exchange():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–∏—Ä–∂–∏"""
    global _exchange_instance
    if _exchange_instance is None:
        _exchange_instance = create_exchange()
        print("OKX exchange instance created")
    return _exchange_instance

def fetch_candles_tf(symbol, timeframe, limit=1):
    """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π"""
    try:
        ex = get_exchange()
        ohlcv = ex.fetch_ohlcv(symbol, timeframe, limit=limit)
        return ohlcv
    except Exception as e:
        print(f"Error fetching {timeframe} candles for {symbol}: {e}")
        return None

def check_connection():
    """Check exchange connection"""
    try:
        ex = get_exchange()
        markets = ex.load_markets()
        print("OKX exchange connected successfully")
        return True
    except Exception as e:
        print(f"Exchange connection error: {e}")
        return False

def place_order(action, price, amount=0.001):
    """–†–µ–∞–ª—å–Ω–∞—è –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞"""
    try:
        ex = get_exchange()
        side = "buy" if action.upper() == "BUY" else "sell"
        order = ex.create_limit_order(SYMBOL, side, amount, price)
        print(f"Order placed: {order}")
        return order
    except Exception as e:
        print(f"Order error: {e}")
        return None

===== fvg_detector.py =====


# fvg_detector.py
from exchange import fetch_candles_tf
from config import SYMBOL, FVG_TF

reported_fvg = {}

def detect_fvg():
    """
    –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ FVG —Å—Ç—Ä–æ–≥–æ –ø–æ –ó–ê–ö–†–´–¢–´–ú —Å–≤–µ—á–∞–º.
    –ë–µ—Ä—ë–º 4 —Å–≤–µ—á–∏, —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –∏—Å–∫–ª—é—á–∏—Ç—å —Ç–µ–∫—É—â—É—é (–Ω–µ–∑–∞–∫—Ä—ã—Ç—É—é).
    –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ç—Ä–∏ –∑–∞–∫—Ä—ã—Ç—ã–µ:
        first  = n-3
        second = n-2
        third  = n-1 (—Ç–∞, –∫–æ—Ç–æ—Ä–∞—è —Ç–æ–ª—å–∫–æ —á—Ç–æ –∑–∞–∫—Ä—ã–ª–∞—Å—å)
    """
    try:
        candles = fetch_candles_tf(SYMBOL, FVG_TF, 4)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º timeframe –∏–∑ config
        if not candles or len(candles) < 4:
            return None

        # –í—Å–µ —Ç—Ä–∏ —Å–≤–µ—á–∏ ‚Äî –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–∫—Ä—ã—Ç—ã–µ
        first  = candles[-4]   # n-3
        second = candles[-3]   # n-2
        third  = candles[-2]   # n-1

        # –î–∞–Ω–Ω—ã–µ –ø–æ —Å–≤–µ—á–∞–º
        first_high, first_low = first[2], first[3]
        second_high, second_low = second[2], second[3]
        third_high, third_low = third[2], third[3]

        # –ë–´–ß–ò–ô FVG (Fair Value Gap –≤–≤–µ—Ä—Ö)
        bull_fvg = third_low > first_high

        # –ú–ï–î–í–ï–ñ–ò–ô FVG (Fair Value Gap –≤–Ω–∏–∑)
        bear_fvg = third_high < first_low

        if not bull_fvg and not bear_fvg:
            return None

        if bull_fvg:
            fvg_type = "BULL_FVG"
            top = third_low      # –Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≥—ç–ø–∞
            bottom = first_high  # –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≥—ç–ø–∞
        else:
            fvg_type = "BEAR_FVG"
            top = first_low      # –Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≥—ç–ø–∞
            bottom = third_high  # –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞ –≥—ç–ø–∞

        key = f"{fvg_type}_{top}_{bottom}"

        if key not in reported_fvg:
            reported_fvg[key] = True
            return {
                "type": fvg_type,
                "top": top,
                "bottom": bottom,
                "direction": "BULL" if fvg_type == "BULL_FVG" else "BEAR"
            }

        return None

    except Exception as e:
        print(f"FVG detection error: {e}")
        return None


===== levels.py =====


# levels.py
from exchange import fetch_candles_tf
from config import SYMBOL, LEVEL_TF

reported_breakouts = {}  # –•—Ä–∞–Ω–∏–º —É–∂–µ –ø—Ä–æ–±–∏—Ç—ã–µ —É—Ä–æ–≤–Ω–∏
last_level_timestamp = None


def find_current_levels():
    """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç high –∏ low –ø–æ—Å–ª–µ–¥–Ω–µ–π –∑–∞–∫—Ä—ã—Ç–æ–π —Å–≤–µ—á–∏ —Å—Ç–∞—Ä—à–µ–≥–æ –¢–§ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 4h)."""
    levels = []

    try:
        candles = fetch_candles_tf(SYMBOL, LEVEL_TF, 2)
        if not candles or len(candles) < 2:
            print("ERROR: –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É—Ä–æ–≤–Ω–µ–π")
            return []

        prev_candle = candles[-2]  # –ü–æ—Å–ª–µ–¥–Ω—è—è –∑–∞–∫—Ä—ã—Ç–∞—è —Å–≤–µ—á–∞
        timestamp = prev_candle[0]
        high = prev_candle[2]
        low = prev_candle[3]

        levels.append((f"{LEVEL_TF.upper()}_HIGH", high, timestamp))
        levels.append((f"{LEVEL_TF.upper()}_LOW", low, timestamp))

        print(f"DEBUG: {LEVEL_TF.upper()} Levels ‚Äî HIGH: {high}, LOW: {low}")
        return levels

    except Exception as e:
        print(f"ERROR in find_current_levels: {e}")
        return []


def check_level_breakout(current_price, levels):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–æ–±–∏—Ç–∏–µ —É—Ä–æ–≤–Ω–µ–π (–≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑)."""
    print(f"DEBUG: Checking BREAKOUTS ‚Äî Current price: {current_price}")

    for level_type, level_price, level_timestamp in levels:
        key = f"{level_type}_{level_price}"

        # –ï—Å–ª–∏ —Å–≤–µ—á–∞ —Å–º–µ–Ω–∏–ª–∞—Å—å ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
        if key in reported_breakouts and reported_breakouts[key] != level_timestamp:
            del reported_breakouts[key]

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ–±–æ–π
        if key not in reported_breakouts:
            if level_type.endswith('HIGH') and current_price > level_price:
                print(f"üü¢ BREAKOUT UP ‚Äî {level_type} {current_price} > {level_price}")
                reported_breakouts[key] = level_timestamp
                return {
                    "type": level_type,
                    "price": level_price,
                    "direction": "UP",
                    "current": current_price
                }

            elif level_type.endswith('LOW') and current_price < level_price:
                print(f"üî¥ BREAKOUT DOWN ‚Äî {level_type} {current_price} < {level_price}")
                reported_breakouts[key] = level_timestamp
                return {
                    "type": level_type,
                    "price": level_price,
                    "direction": "DOWN",
                    "current": current_price
                }

    print("DEBUG: No breakouts detected")
    return None


def check_new_candles():
    """–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –ø–æ—è–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π —Å–≤–µ—á–∏ –Ω–∞ —Å—Ç–∞—Ä—à–µ–º –¢–§."""
    global last_level_timestamp

    try:
        candles = fetch_candles_tf(SYMBOL, LEVEL_TF, 1)
        if not candles:
            return None

        current_timestamp = candles[0][0]

        if last_level_timestamp is None:
            last_level_timestamp = current_timestamp
        elif current_timestamp != last_level_timestamp:
            last_level_timestamp = current_timestamp
            return f"{LEVEL_TF.upper()}_NEW"

        return None

    except Exception as e:
        print(f"ERROR in check_new_candles: {e}")
        return None


def check_smc_levels():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ–µ–≤ —É—Ä–æ–≤–Ω–µ–π."""
    try:
        print(f"DEBUG: === {LEVEL_TF.upper()} BREAKOUT CHECK STARTED ===")

        # –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –ø–æ 1-–º–∏–Ω—É—Ç–Ω–æ–π —Å–≤–µ—á–µ
        current_candle = fetch_candles_tf(SYMBOL, "1m", 1)
        if not current_candle:
            print("DEBUG: No 1m candle data")
            return None

        current_price = current_candle[0][4]
        print(f"DEBUG: Current 1m price: {current_price}")

        levels = find_current_levels()
        result = check_level_breakout(current_price, levels)

        if result:
            print(f"üö® BREAKOUT DETECTED: {result}")
        else:
            print("DEBUG: No breakout signal")

        print(f"DEBUG: === {LEVEL_TF.upper()} BREAKOUT CHECK FINISHED ===")
        return result

    except Exception as e:
        print(f"ERROR in check_smc_levels: {e}")
        return None


===== main.py =====


# main.py
import time
import threading
import gc
import requests
from exchange import check_connection, fetch_candles_tf
from telegram import send_startup_message, send_telegram_message, send_error_message
from callback_handler import handle_callback
from config import TELEGRAM_BOT_TOKEN, check_env_variables, SYMBOL, FVG_TF, LEVEL_TF
from levels import check_smc_levels, check_new_candles, find_current_levels
from fvg_detector import detect_fvg


def get_updates(offset=None):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–ø–¥–µ–π—Ç–æ–≤ –∏–∑ Telegram"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'timeout': 30, 'offset': offset}
    try:
        response = requests.get(url, params=params, timeout=35)
        return response.json()
    except:
        return {'result': []}


def process_updates():
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ Telegram-–∫–Ω–æ–ø–æ–∫"""
    last_update_id = None
    print("üì® Starting Telegram updates polling...")

    while True:
        try:
            updates = get_updates(last_update_id)
            if updates.get('result'):
                for update in updates['result']:
                    if 'callback_query' in update:
                        callback_data = update['callback_query']['data']
                        print(f"üì• Received callback: {callback_data}")
                        handle_callback(callback_data)
                    last_update_id = update['update_id'] + 1
            time.sleep(1)
        except Exception as e:
            print(f"‚ö†Ô∏è Updates error: {e}")
            time.sleep(5)


def main():
    print("üöÄ Starting SMC Levels Bot...")

    if not check_env_variables():
        print("‚õî –û—Å—Ç–∞–Ω–æ–≤–∫–∞: –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        return

    send_startup_message()

    if not check_connection():
        print("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ OKX")
        return

    # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É Telegram callback'–æ–≤ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    polling_thread = threading.Thread(target=process_updates, daemon=True)
    polling_thread.start()
    print("‚úÖ Telegram polling thread started")

    # –¢–∞–π–º–∏–Ω–≥–∏
    last_signal_time = 0
    last_candle_check_time = 0
    last_levels_check_time = 0

    # –î–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è FVG ‚Äî —á—Ç–æ–±—ã –Ω–µ –∏—Å–∫–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ –Ω–∞ —Ç–æ–π –∂–µ —Å–≤–µ—á–µ
    last_fvg_candle = None

    print(f"üß≠ Monitoring {LEVEL_TF.upper()} levels + {FVG_TF.upper()} FVG search...")

    while True:
        try:
            current_time = int(time.time() * 1000)

            # === FVG SEARCH ===
            from callback_handler import fvg_search_active
            if fvg_search_active:
                candles = fetch_candles_tf(SYMBOL, FVG_TF, 2)
                if candles and len(candles) >= 2:
                    last_closed_ts = candles[-2][0]

                    if last_fvg_candle != last_closed_ts:
                        last_fvg_candle = last_closed_ts

                        print(f"üîç FVG SEARCH: Checking closed {FVG_TF} candle...")
                        fvg_signal = detect_fvg()

                        if fvg_signal:
                            print(f"üéØ FVG FOUND: {fvg_signal}")
                            message = f"FVG found ({fvg_signal['direction']})"
                            send_telegram_message("fvg", "", "", "", message)
                        else:
                            print("‚ùå No FVG on this candle")


            # === –ü–†–û–í–ï–†–ö–ê –ü–†–û–ë–û–ï–í –£–†–û–í–ù–ï–ô === (—Ä–∞–∑ –≤ 60 —Å–µ–∫)
            if current_time - last_levels_check_time > 60000:
                print(f"\nüïí [{time.strftime('%H:%M:%S')}] Checking {LEVEL_TF.upper()} breakouts...")
                signal = check_smc_levels()

                if signal:
                    if current_time - last_signal_time > 60000:
                        print(f"üì® Level breakout detected: {signal}")
                        message = f"break {signal['price']} ({signal['direction']})"
                        send_telegram_message("breakout", "", "", "", message)
                        last_signal_time = current_time
                    else:
                        print("‚è≥ Cooldown ‚Äî skipping duplicate breakout...")
                else:
                    print("üìä No breakouts detected.")

                last_levels_check_time = current_time


            # === –ü–†–û–í–ï–†–ö–ê –ù–û–í–´–• –°–í–ï–ß–ï–ô –°–¢–ê–†–®–ï–ì–û –¢–§ ===
            if current_time - last_candle_check_time > 60000:
                new_candle = check_new_candles()

                if new_candle:
                    print(f"üîÑ New candle detected: {new_candle}")
                    levels = find_current_levels()

                    levels_text = ""
                    for level_type, level_price, _ in levels:
                        if level_type.startswith(LEVEL_TF.upper()):
                            tf, l_type = level_type.split('_')
                            levels_text += f"{l_type.lower()} {level_price}\n"

                    timeframe = new_candle.replace('_NEW', '').lower()
                    message = f"update {timeframe}\n{levels_text}"
                    send_telegram_message("update", "", "", "", message)

                last_candle_check_time = current_time


            # === –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è ===
            gc.collect()
            time.sleep(6)

        except KeyboardInterrupt:
            print("\nüõë Bot stopped manually.")
            break
        except Exception as e:
            print(f"‚ùå Bot error: {e}")
            send_error_message(str(e))
            time.sleep(30)


if __name__ == "__main__":
    main()


===== telegram.py =====


# telegram.py
import json
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, SYMBOL

def send_telegram_message(title, time_str, entry, stop_loss, take_profit, keyboard=None):
    """
    Send a message to Telegram.
    """
    message = take_profit  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
    
    # –ï—Å–ª–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é
    if keyboard is None:
        # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∑–¥–µ—Å—å —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–∏—á–µ—Å–∫–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞
        from callback_handler import fvg_search_active
        
        # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ FVG SEARCH
        button_text = "FVG SEARCH" if not fvg_search_active else "FVG SEARCH"
        
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': button_text, 'callback_data': 'TOGGLE_FVG_SEARCH'}
                ]
            ]
        }
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': message,
            'parse_mode': 'HTML',
            'reply_markup': json.dumps(keyboard) if keyboard else None
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def send_startup_message():
    try:
        from exchange import get_exchange
        from levels import find_current_levels
        
        ex = get_exchange()
        balance = ex.fetch_balance()
        usdt_balance = balance['total'].get('USDT', 0)
        rounded_balance = round(usdt_balance, 1)
        
        levels = find_current_levels()
        
        # –ò–ó–ú–ï–ù–ò–õ –§–û–†–ú–ê–¢ –°–û–û–ë–©–ï–ù–ò–Ø
        levels_text = ""
        for level_type, level_price, _ in levels:
            if level_type.startswith('4H'):
                tf, l_type = level_type.split('_')
                levels_text += f"{l_type.lower()} {level_price}\n"
        
        message = f"""{SYMBOL}
{levels_text}"""
        
        send_telegram_message("startup", "", "", "", message)
    except Exception as e:
        message = f"""{SYMBOL}
error - {e}"""
        send_telegram_message("startup", "", "", "", message)

def send_error_message(error):
    message = f"Bot error: {error}"
    send_telegram_message("error", "", "", "", message)

===== test_api.py =====


# test_api.py
from exchange import create_exchange
ex = create_exchange()
try:
    candles = ex.fetch_ohlcv("BTC/USDT:USDT", "1m", limit=1)
    print("API —Ä–∞–±–æ—Ç–∞–µ—Ç:", candles[0] if candles else "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
except Exception as e:
    print("–û—à–∏–±–∫–∞ API:", e)
