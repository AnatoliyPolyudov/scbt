

===== callback_handler.py =====


# callback_handler.py
from event_bus import publish

def handle_callback(query_data):
    print("CALLBACK_HANDLER: Received callback:", query_data)
    
    if ':' in query_data:
        # –õ–∏–º–∏—Ç–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞ —Å —Ü–µ–Ω–æ–π: BUY_LIMIT:3800.50 –∏–ª–∏ SELL_LIMIT:3800.50
        action, price = query_data.split(':')
        publish("BUTTON_CLICK", {"action": action, "price": price})
    else:
        # –ö–Ω–æ–ø–∫–∞ –±–µ–∑ —Ü–µ–Ω—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä BALANCE
        publish("BUTTON_CLICK", {"action": query_data})



===== config.py =====


# config.py
import os
from dotenv import load_dotenv

load_dotenv()  # –∑–∞–≥—Ä—É–∂–∞–µ—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ .env

SYMBOL = "BTC/USDT:USDT"
TF = "1m"
CAPITAL = 500
RISK_PERCENT = 1

# Telegram
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

# –ë–∏—Ä–∂–∞ OKX
OKX_API_KEY = os.getenv("OKX_API_KEY")
OKX_SECRET_KEY = os.getenv("OKX_SECRET_KEY")
OKX_PASSPHRASE = os.getenv("OKX_PASSPHRASE")

CANDLES_NEEDED = 3

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
def check_env_variables():
    required_vars = {
        "TELEGRAM_BOT_TOKEN": TELEGRAM_BOT_TOKEN,
        "TELEGRAM_CHAT_ID": TELEGRAM_CHAT_ID,
        "OKX_API_KEY": OKX_API_KEY,
        "OKX_SECRET_KEY": OKX_SECRET_KEY,
        "OKX_PASSPHRASE": OKX_PASSPHRASE
    }
    
    missing_vars = []
    for name, value in required_vars.items():
        if not value:
            missing_vars.append(name)
    
    if missing_vars:
        print(f"–û—à–∏–±–∫–∞: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}")
        return False
    
    print("–í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
    return True

===== event_bus.py =====


subscribers = {}

def subscribe(event_type, callback):
    if event_type not in subscribers:
        subscribers[event_type] = []
    subscribers[event_type].append(callback)

def publish(event_type, data):
    if event_type in subscribers:
        for callback in subscribers[event_type]:
            callback(data)


===== exchange.py =====


# exchange.py
import ccxt
from config import SYMBOL, TF, OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE

def create_exchange():
    """–°–æ–∑–¥–∞–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç –±–∏—Ä–∂–∏"""
    print(f"DEBUG: Creating exchange with API Key: {OKX_API_KEY[:10]}...")  # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    
    if not all([OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE]):
        raise Exception("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è OKX. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª .env")
    
    return ccxt.okx({
        "apiKey": OKX_API_KEY,
        "secret": OKX_SECRET_KEY,
        "password": OKX_PASSPHRASE,
        "enableRateLimit": True,
        "options": {"defaultType": "swap"}
    })

def fetch_candles(limit=3):
    """Fetch candles from exchange - returns list instead of DataFrame"""
    try:
        ex = create_exchange()
        ohlcv = ex.fetch_ohlcv(SYMBOL, TF, limit=limit)
        return ohlcv
    except Exception as e:
        print(f"Error fetching data: {e}")
        return []

def check_connection():
    """Check exchange connection"""
    try:
        ex = create_exchange()
        markets = ex.load_markets()
        print("OKX exchange connected successfully")
        return True
    except Exception as e:
        print(f"Exchange connection error: {e}")
        return False

def place_order(action, price, amount=None):
    """
    –†–µ–∞–ª—å–Ω–∞—è –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞.
    action: 'BUY' –∏–ª–∏ 'SELL'
    price: —Ü–µ–Ω–∞ –æ—Ä–¥–µ—Ä–∞
    amount: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ USDT (–µ—Å–ª–∏ None, –±–µ—Ä–µ—Ç—Å—è 1% —Ä–∏—Å–∫–∞ = 5 USDT)
    """
    try:
        ex = create_exchange()
        side = "buy" if action.upper() == "BUY" else "sell"
        
        if amount is None:
            # 1% –æ—Ç 500 USDT = 5 USDT
            amount = 5
            
        print(f"Placing {side} order: {amount} USDT at {price}")
        
        order = ex.create_limit_order(SYMBOL, side, amount, price)
        print(f"Order placed: {order}")
        return order
    except Exception as e:
        print(f"Order error: {e}")
        return None


===== main.py =====


# main.py
import order_manager
import time
import threading
import gc
import requests
from exchange import check_connection
from patterns import check_scob_pattern, wait_for_candle_close
from telegram import send_startup_message, send_telegram_message, send_error_message
from callback_handler import handle_callback
from config import TELEGRAM_BOT_TOKEN, check_env_variables  # –¥–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É

def get_updates(offset=None):
    """Get updates from Telegram via polling"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'timeout': 30, 'offset': offset}
    try:
        response = requests.get(url, params=params, timeout=35)
        return response.json()
    except:
        return {'result': []}

def process_updates():
    """Process Telegram updates in background"""
    last_update_id = None
    print("Starting Telegram updates polling...")

    while True:
        try:
            updates = get_updates(last_update_id)
            if updates.get('result'):
                for update in updates['result']:
                    if 'callback_query' in update:
                        callback_data = update['callback_query']['data']
                        print(f"Received callback: {callback_data}")
                        handle_callback(callback_data)
                    last_update_id = update['update_id'] + 1
            time.sleep(1)
        except Exception as e:
            print(f"Updates error: {e}")
            time.sleep(5)

def main():
    print("Starting ScoB Bot...")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
    if not check_env_variables():
        print("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        return
    
    print("Monitoring patterns...")

    send_startup_message()

    if not check_connection():
        return

    polling_thread = threading.Thread(target=process_updates, daemon=True)
    polling_thread.start()
    print("Telegram polling started")

    last_signal_time = 0

    while True:
        try:
            wait_for_candle_close()
            signal = check_scob_pattern()  # –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–∏–Ω —Å–∏–≥–Ω–∞–ª

            if signal:
                current_time = int(time.time() * 1000)
                if current_time - last_signal_time > 60000:
                    send_telegram_message(
                        signal["title"],
                        signal["time"],
                        signal["entry"],
                        signal["stop_loss"],
                        signal["take_profit"]
                    )
                    last_signal_time = current_time

            gc.collect()
            time.sleep(6)

        except KeyboardInterrupt:
            print("Bot stopped manually")
            break
        except Exception as e:
            print(f"Bot error: {e}")
            send_error_message(str(e))
            time.sleep(30)

if __name__ == "__main__":
    main()

===== order_manager.py =====


# order_manager.py
from event_bus import subscribe
from exchange import place_order
from telegram import send_balance

def handle_button_click(data):
    print("ORDER_MANAGER: Received button click:", data)
    
    action = data.get("action")
    
    # –î–ª—è –ª–∏–º–∏—Ç–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è —Ü–µ–Ω–∞
    price = data.get("price")
    if price:
        price = float(price)

    if action == "BUY_LIMIT":
        print(f"Placing BUY LIMIT at {price}")
        place_order("BUY", price)
    elif action == "SELL_LIMIT":
        print(f"Placing SELL LIMIT at {price}")
        place_order("SELL", price)
    elif action == "BALANCE":
        print("–ó–∞–ø—Ä–æ—Å –±–∞–ª–∞–Ω—Å–∞")
        send_balance()  # –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –≤ —Ç–µ–ª–µ–≥—Ä–∞–º

# –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Å–æ–±—ã—Ç–∏–µ –∫–Ω–æ–ø–æ–∫
subscribe("BUTTON_CLICK", handle_button_click)


===== patterns.py =====


# patterns.py
import time
from datetime import datetime
from exchange import fetch_candles, SYMBOL
from config import CANDLES_NEEDED
import numpy as np
import talib

def wait_for_candle_close():
    current_time = int(time.time() * 1000)
    candle_duration = 60000  # 1 minutes
    next_candle_time = (current_time // candle_duration + 1) * candle_duration
    wait_time = (next_candle_time - current_time) / 1000
    if wait_time > 0:
        print(f"Waiting for candle close: {wait_time:.1f} sec")
        time.sleep(wait_time)

def check_scob_pattern():
    """Detect Single Candle Order Block (ScoB) pattern"""
    print("Analyzing candles for ScoB pattern...")

    # –ë–µ—Ä–µ–º –Ω–∞ 1 —Å–≤–µ—á—É –±–æ–ª—å—à–µ, —á—Ç–æ–±—ã –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–≤–µ—á–∏
    candles = fetch_candles(limit=CANDLES_NEEDED + 21)
    if len(candles) < CANDLES_NEEDED + 21:
        print("Not enough candles for analysis")
        return None

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–≤–µ—á–∏ c1, c2, c3 - –≤—Å–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–∫—Ä—ã—Ç—ã–º–∏
    # –ë–µ—Ä–µ–º —Å–≤–µ—á–∏ -4, -3, -2 (–≤–º–µ—Å—Ç–æ -3, -2, -1)
    c1, c2, c3 = candles[-4], candles[-3], candles[-2]
    high1, low1, close1 = c1[2], c1[3], c1[4]
    high2, low2, close2 = c2[2], c2[3], c2[4]
    high3, low3, close3 = c3[2], c3[3], c3[4]

    time_str = datetime.fromtimestamp(c3[0] / 1000).strftime('%H:%M')

    # LONG pattern - –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–≤–µ—á–∏
    if low2 < low1 and close2 > low1 and close3 > high2:
        entry = high2
        stop_loss = low2
        take_profit = entry + (entry - stop_loss) * 2
        print(f"ScoB LONG pattern detected at {time_str}")
        return {
            "title": "long",
            "time": time_str,
            "entry": round(entry, 2),
            "stop_loss": round(stop_loss, 2),
            "take_profit": round(take_profit, 2)
        }

    # SHORT pattern - –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–≤–µ—á–∏
    elif high2 > high1 and close2 < high1 and close3 < low2:
        entry = low2
        stop_loss = high2
        take_profit = entry - (stop_loss - entry) * 2
        print(f"ScoB SHORT pattern detected at {time_str}")
        return {
            "title": "short",
            "time": time_str,
            "entry": round(entry, 2),
            "stop_loss": round(stop_loss, 2),
            "take_profit": round(take_profit, 2)
        }

    print(f"No ScoB pattern found at {time_str}")
    return None

===== telegram.py =====


# telegram.py
import json
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, SYMBOL, TF, CAPITAL, RISK_PERCENT
from utils import calculate_position

def send_telegram_message(title, time_str, entry, stop_loss, take_profit):
    """
    Send a message to Telegram.
    If entry and stop_loss are set, include position info.
    """
    if entry and stop_loss:
        size, position_info = calculate_position(float(entry), float(stop_loss))
        message = f"""scob {title}
{time_str}
entry: {entry}
stop: {stop_loss}
tp: {take_profit}

{position_info}"""
        
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': 'BUY LIMIT', 'callback_data': f'BUY_LIMIT:{entry}'},
                    {'text': 'SELL LIMIT', 'callback_data': f'SELL_LIMIT:{entry}'},
                    {'text': 'BALANCE', 'callback_data': 'BALANCE'}
                ]
            ]
        }
    else:
        message = take_profit
        keyboard = None
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': message,
            'parse_mode': 'HTML',
            'reply_markup': json.dumps(keyboard) if keyboard else None
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def send_startup_message():
    try:
        from exchange import create_exchange
        ex = create_exchange()
        balance = ex.fetch_balance()
        usdt_balance = balance['total'].get('USDT', 0)
        rounded_balance = round(usdt_balance, 1)
        
        message = f"started\n{SYMBOL}\n{TF}\n{CAPITAL} USDT\n{RISK_PERCENT}%\n{rounded_balance} USDT"
        send_telegram_message("startup", "", "", "", message)
    except Exception as e:
        message = f"started\n{SYMBOL}\n{TF}\n{CAPITAL} USDT\n{RISK_PERCENT}%\nBalance: error"
        send_telegram_message("startup", "", "", "", message)

def send_error_message(error):
    """Send error message to Telegram"""
    message = f"Bot error: {error}"
    send_telegram_message("error", "", "", "", message)

def send_balance():
    """Send current account balance to Telegram"""
    try:
        from exchange import create_exchange
        ex = create_exchange()
        balance = ex.fetch_balance()
        usdt_balance = balance['total'].get('USDT', 0)
        message = f"{round(usdt_balance, 1)} USDT"
        send_telegram_message("BALANCE", "", "", "", message)
    except Exception as e:
        send_error_message(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")

def set_webhook():
    url = "http://194.87.238.84:5000/webhook"
    try:
        response = requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setWebhook",
            data={"url": url}
        )
        print(f"Webhook set: {response.status_code}")
    except Exception as e:
        print(f"Error setting webhook: {e}")

===== utils.py =====


# utils.py
from config import CAPITAL, RISK_PERCENT

def calculate_position(entry_price, stop_loss_price):
    """Calculate position size based on risk management"""
    risk_amount = CAPITAL * (RISK_PERCENT / 100)
    price_diff = abs(entry_price - stop_loss_price)
    
    if price_diff == 0:
        raise ValueError("Stop-loss cannot be zero")
    
    size = risk_amount / price_diff
    
    position_info = f"""Amount: {CAPITAL} USDT
Risk: {RISK_PERCENT}% = {risk_amount:.2f} USDT
Position size: {size:.4f} ETH"""
    
    print(position_info)
    return size, position_info


===== callback_handler.py =====


# callback_handler.py
from event_bus import publish

def handle_callback(query_data):
    print("CALLBACK_HANDLER: Received callback:", query_data)
    
    if ':' in query_data:
        # –õ–∏–º–∏—Ç–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞ —Å —Ü–µ–Ω–æ–π: BUY_LIMIT:3800.50 –∏–ª–∏ SELL_LIMIT:3800.50
        action, price = query_data.split(':')
        publish("BUTTON_CLICK", {"action": action, "price": price})
    else:
        # –ö–Ω–æ–ø–∫–∞ –±–µ–∑ —Ü–µ–Ω—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä BALANCE
        publish("BUTTON_CLICK", {"action": query_data})



===== config.py =====


# config.py
import os
from dotenv import load_dotenv

load_dotenv()

SYMBOL = "BTC/USDT:USDT"
TF = "1m"
CAPITAL = 500
RISK_PERCENT = 1

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

OKX_API_KEY = os.getenv("OKX_API_KEY")
OKX_SECRET_KEY = os.getenv("OKX_SECRET_KEY")
OKX_PASSPHRASE = os.getenv("OKX_PASSPHRASE")

CANDLES_NEEDED = 3

def check_env_variables():
    required_vars = {
        "TELEGRAM_BOT_TOKEN": TELEGRAM_BOT_TOKEN,
        "TELEGRAM_CHAT_ID": TELEGRAM_CHAT_ID,
        "OKX_API_KEY": OKX_API_KEY,
        "OKX_SECRET_KEY": OKX_SECRET_KEY,
        "OKX_PASSPHRASE": OKX_PASSPHRASE
    }
    
    missing_vars = []
    for name, value in required_vars.items():
        if not value:
            missing_vars.append(name)
    
    if missing_vars:
        print(f"–û—à–∏–±–∫–∞: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: {', '.join(missing_vars)}")
        return False
    
    print("–í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ")
    return True


===== event_bus.py =====


subscribers = {}

def subscribe(event_type, callback):
    if event_type not in subscribers:
        subscribers[event_type] = []
    subscribers[event_type].append(callback)

def publish(event_type, data):
    if event_type in subscribers:
        for callback in subscribers[event_type]:
            callback(data)


===== exchange.py =====


# exchange.py
import ccxt
from config import SYMBOL, TF, OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE

_exchange_instance = None

def create_exchange():
    """–°–æ–∑–¥–∞–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç –±–∏—Ä–∂–∏"""
    if not all([OKX_API_KEY, OKX_SECRET_KEY, OKX_PASSPHRASE]):
        raise Exception("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è OKX. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª .env")
    
    return ccxt.okx({
        "apiKey": OKX_API_KEY,
        "secret": OKX_SECRET_KEY,
        "password": OKX_PASSPHRASE,
        "enableRateLimit": True,
        "options": {"defaultType": "swap"}
    })

def get_exchange():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–∏—Ä–∂–∏"""
    global _exchange_instance
    if _exchange_instance is None:
        _exchange_instance = create_exchange()
        print("OKX exchange instance created")
    return _exchange_instance

def fetch_candles_tf(symbol, timeframe, limit=1):
    """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π"""
    try:
        ex = get_exchange()
        ohlcv = ex.fetch_ohlcv(symbol, timeframe, limit=limit)
        return ohlcv
    except Exception as e:
        print(f"Error fetching {timeframe} candles for {symbol}: {e}")
        return None

def check_connection():
    """Check exchange connection"""
    try:
        ex = get_exchange()
        markets = ex.load_markets()
        print("OKX exchange connected successfully")
        return True
    except Exception as e:
        print(f"Exchange connection error: {e}")
        return False

def place_order(action, price, amount=0.001):
    """–†–µ–∞–ª—å–Ω–∞—è –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞"""
    try:
        ex = get_exchange()
        side = "buy" if action.upper() == "BUY" else "sell"
        order = ex.create_limit_order(SYMBOL, side, amount, price)
        print(f"Order placed: {order}")
        return order
    except Exception as e:
        print(f"Order error: {e}")
        return None


===== levels.py =====


# levels.py
from exchange import fetch_candles_tf
from config import SYMBOL

reported_levels = {}
last_4h_timestamp = None
last_1h_timestamp = None

def find_current_levels():
    """–ù–∞–π—Ç–∏ —É—Ä–æ–≤–Ω–∏ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–≤–µ—á–µ–π 4H –∏ 1H"""
    levels = []

    try:
        # 4H –ø—Ä–µ–¥—ã–¥—É—â–∞—è –∑–∞–∫—Ä—ã—Ç–∞—è —Å–≤–µ—á–∞
        c4 = fetch_candles_tf(SYMBOL, "4h", 2)
        if c4 and len(c4) >= 2:
            prev_candle = c4[-2]
            timestamp = prev_candle[0]
            levels.append(("4H_HIGH", prev_candle[2], timestamp))
            levels.append(("4H_LOW", prev_candle[3], timestamp))

        # 1H –ø—Ä–µ–¥—ã–¥—É—â–∞—è –∑–∞–∫—Ä—ã—Ç–∞—è —Å–≤–µ—á–∞
        c1 = fetch_candles_tf(SYMBOL, "1h", 2)
        if c1 and len(c1) >= 2:
            prev_candle = c1[-2]
            timestamp = prev_candle[0]
            levels.append(("1H_HIGH", prev_candle[2], timestamp))
            levels.append(("1H_LOW", prev_candle[3], timestamp))

        return levels
        
    except Exception as e:
        print(f"Error in find_current_levels: {e}")
        return []

def check_level_touch(current_price, levels):
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–æ—á–Ω–æ–µ –∫–∞—Å–∞–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π"""
    for level_type, level_price, level_timestamp in levels:
        if current_price == level_price:
            key = f"{level_type}_{level_price}"
            
            if key in reported_levels:
                if reported_levels[key] != level_timestamp:
                    del reported_levels[key]
            
            if key not in reported_levels:
                reported_levels[key] = level_timestamp
                return {
                    "type": level_type,
                    "price": level_price
                }
    return None

def check_new_candles():
    """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–º–µ–Ω—É —Å–≤–µ—á–µ–π 4H –∏ 1H"""
    global last_4h_timestamp, last_1h_timestamp
    
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º 4H —Å–≤–µ—á—É
        c4 = fetch_candles_tf(SYMBOL, "4h", 1)
        if c4:
            current_4h_timestamp = c4[0][0]
            if last_4h_timestamp is None:
                last_4h_timestamp = current_4h_timestamp
            elif current_4h_timestamp != last_4h_timestamp:
                last_4h_timestamp = current_4h_timestamp
                return "4H_NEW"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º 1H —Å–≤–µ—á—É
        c1 = fetch_candles_tf(SYMBOL, "1h", 1)
        if c1:
            current_1h_timestamp = c1[0][0]
            if last_1h_timestamp is None:
                last_1h_timestamp = current_1h_timestamp
            elif current_1h_timestamp != last_1h_timestamp:
                last_1h_timestamp = current_1h_timestamp
                return "1H_NEW"
                
        return None
        
    except Exception as e:
        print(f"Error checking new candles: {e}")
        return None

def check_smc_levels():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Ä–æ–≤–Ω–µ–π"""
    try:
        current_candle = fetch_candles_tf(SYMBOL, "1m", 1)
        if not current_candle:
            return None

        current_price = current_candle[0][4]
        levels = find_current_levels()
        return check_level_touch(current_price, levels)
        
    except Exception as e:
        print(f"Levels check error: {e}")
        return None


===== main.py =====


# main.py
import order_manager
import time
import threading
import gc
import requests
from exchange import check_connection
from telegram import send_startup_message, send_telegram_message, send_error_message
from callback_handler import handle_callback
from config import TELEGRAM_BOT_TOKEN, check_env_variables
from levels import check_smc_levels, check_new_candles, find_current_levels

def get_updates(offset=None):
    """Get updates from Telegram via polling"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/getUpdates"
    params = {'timeout': 30, 'offset': offset}
    try:
        response = requests.get(url, params=params, timeout=35)
        return response.json()
    except:
        return {'result': []}

def process_updates():
    """Process Telegram updates in background"""
    last_update_id = None
    print("Starting Telegram updates polling...")

    while True:
        try:
            updates = get_updates(last_update_id)
            if updates.get('result'):
                for update in updates['result']:
                    if 'callback_query' in update:
                        callback_data = update['callback_query']['data']
                        print(f"Received callback: {callback_data}")
                        handle_callback(callback_data)
                    last_update_id = update['update_id'] + 1
            time.sleep(1)
        except Exception as e:
            print(f"Updates error: {e}")
            time.sleep(5)

def main():
    print("Starting SMC Levels Bot...")
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
    if not check_env_variables():
        print("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")
        return
    
    print("Monitoring 4H/1H levels...")

    send_startup_message()

    if not check_connection():
        return

    polling_thread = threading.Thread(target=process_updates, daemon=True)
    polling_thread.start()
    print("Telegram polling started")

    last_signal_time = 0
    last_candle_check_time = 0

    while True:
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Å–∞–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π
            signal = check_smc_levels()

            if signal:
                current_time = int(time.time() * 1000)
                if current_time - last_signal_time > 60000:  # –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ø–∞–º–∞ 60 —Å–µ–∫
                    level_type = signal['type']
                    tf, l_type = level_type.split('_')
                    level_display = f"{tf.lower()} {l_type.lower()}"
                    
                    message = f"üéØ Level Touch\n{level_display}: {signal['price']}"
                    send_telegram_message("level", "", "", "", message)
                    last_signal_time = current_time

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–º–µ–Ω—É —Å–≤–µ—á–µ–π –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
            current_time = int(time.time() * 1000)
            if current_time - last_candle_check_time > 30000:  # –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
                new_candle = check_new_candles()
                if new_candle:
                    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ —É—Ä–æ–≤–Ω–∏
                    levels = find_current_levels()
                    
                    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —É—Ä–æ–≤–Ω–µ–π
                    levels_text = ""
                    levels_4h = []
                    levels_1h = []
                    
                    for level_type, level_price, _ in levels:
                        if level_type.startswith('4H'):
                            levels_4h.append((level_type, level_price))
                        else:
                            levels_1h.append((level_type, level_price))
                    
                    # –£—Ä–æ–≤–Ω–∏ 4H
                    for level_type, level_price in levels_4h:
                        tf, l_type = level_type.split('_')
                        level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
                        levels_text += f"{level_display}\n"
                    
                    # –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –º–µ–∂–¥—É —É—Ä–æ–≤–Ω—è–º–∏
                    levels_text += "\n"
                    
                    # –£—Ä–æ–≤–Ω–∏ 1H
                    for level_type, level_price in levels_1h:
                        tf, l_type = level_type.split('_')
                        level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
                        levels_text += f"{level_display}\n"
                    
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤—ã—Ö —É—Ä–æ–≤–Ω—è—Ö
                    timeframe = new_candle.replace('_NEW', '').lower()
                    message = f"üîÑ New {timeframe} Candle\n\nüìä Updated Levels:\n{levels_text}"
                    send_telegram_message("update", "", "", "", message)
                
                last_candle_check_time = current_time

            gc.collect()
            time.sleep(6)  # –û—Å–Ω–æ–≤–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ —Ü–∏–∫–ª–∞

        except KeyboardInterrupt:
            print("Bot stopped manually")
            break
        except Exception as e:
            print(f"Bot error: {e}")
            send_error_message(str(e))
            time.sleep(30)

if __name__ == "__main__":
    main()


===== order_manager.py =====


# order_manager.py
from event_bus import subscribe
from exchange import place_order
from telegram import send_balance

def handle_button_click(data):
    print("ORDER_MANAGER: Received button click:", data)
    
    action = data.get("action")
    
    price = data.get("price")
    if price:
        price = float(price)

    if action == "BUY_LIMIT":
        print(f"Placing BUY LIMIT at {price}")
        place_order("BUY", price)
    elif action == "SELL_LIMIT":
        print(f"Placing SELL LIMIT at {price}")
        place_order("SELL", price)
    elif action == "BALANCE":
        print("–ó–∞–ø—Ä–æ—Å –±–∞–ª–∞–Ω—Å–∞")
        send_balance()

subscribe("BUTTON_CLICK", handle_button_click)


===== telegram.py =====


# telegram.py
import json
import requests
from config import TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID, SYMBOL, TF, CAPITAL, RISK_PERCENT
from utils import calculate_position

def send_telegram_message(title, time_str, entry, stop_loss, take_profit):
    """
    Send a message to Telegram.
    """
    if entry and stop_loss:
        size, position_info = calculate_position(float(entry), float(stop_loss))
        message = f"""scob {title}
{time_str}
entry: {entry}
stop: {stop_loss}
tp: {take_profit}

{position_info}"""
        
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': 'BALANCE', 'callback_data': 'BALANCE'}
                ]
            ]
        }
    else:
        message = take_profit
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': 'BALANCE', 'callback_data': 'BALANCE'}
                ]
            ]
        }
    
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        payload = {
            'chat_id': TELEGRAM_CHAT_ID,
            'text': message,
            'parse_mode': 'HTML',
            'reply_markup': json.dumps(keyboard) if keyboard else None
        }
        response = requests.post(url, data=payload, timeout=10)
        return response.status_code == 200
    except Exception as e:
        print(f"TELEGRAM_ERROR: {e}")
        return False

def send_startup_message():
    try:
        from exchange import get_exchange
        from levels import find_current_levels
        
        ex = get_exchange()
        balance = ex.fetch_balance()
        usdt_balance = balance['total'].get('USDT', 0)
        rounded_balance = round(usdt_balance, 1)
        
        levels = find_current_levels()
        
        levels_4h = []
        levels_1h = []
        
        for level_type, level_price, _ in levels:
            if level_type.startswith('4H'):
                levels_4h.append((level_type, level_price))
            else:
                levels_1h.append((level_type, level_price))
        
        levels_text = ""
        
        for level_type, level_price in levels_4h:
            tf, l_type = level_type.split('_')
            level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
            levels_text += f"{level_display}\n"
        
        levels_text += "\n"
        
        for level_type, level_price in levels_1h:
            tf, l_type = level_type.split('_')
            level_display = f"{tf.lower()} {l_type.lower()}: {level_price}"
            levels_text += f"{level_display}\n"
        
        message = f"""üöÄ Started
symbol: {SYMBOL}
tf: {TF}
capital: {CAPITAL} USDT
risk: {RISK_PERCENT}%
balance: {rounded_balance} USDT

üìä Current Levels
{levels_text}"""
        
        send_telegram_message("startup", "", "", "", message)
    except Exception as e:
        message = f"""üöÄ Started
symbol: {SYMBOL}
tf: {TF}
capital: {CAPITAL} USDT  
risk: {RISK_PERCENT}%
balance: error
Levels: error - {e}"""
        send_telegram_message("startup", "", "", "", message)

def send_error_message(error):
    message = f"Bot error: {error}"
    send_telegram_message("error", "", "", "", message)

def send_balance():
    try:
        from exchange import get_exchange
        ex = get_exchange()
        balance = ex.fetch_balance()
        usdt_balance = balance['total'].get('USDT', 0)
        message = f"Balance: {round(usdt_balance, 1)} USDT"
        send_telegram_message("BALANCE", "", "", "", message)
    except Exception as e:
        send_error_message(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")

def set_webhook():
    url = "http://194.87.238.84:5000/webhook"
    try:
        response = requests.post(
            f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/setWebhook",
            data={"url": url}
        )
        print(f"Webhook set: {response.status_code}")
    except Exception as e:
        print(f"Error setting webhook: {e}")


===== test_api.py =====


# test_api.py
from exchange import create_exchange
ex = create_exchange()
try:
    candles = ex.fetch_ohlcv("BTC/USDT:USDT", "1m", limit=1)
    print("API —Ä–∞–±–æ—Ç–∞–µ—Ç:", candles[0] if candles else "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö")
except Exception as e:
    print("–û—à–∏–±–∫–∞ API:", e)


===== utils.py =====


# utils.py
from config import CAPITAL, RISK_PERCENT, SYMBOL

def calculate_position(entry_price, stop_loss_price):
    """Calculate position size based on risk management"""
    risk_amount = CAPITAL * (RISK_PERCENT / 100)
    price_diff = abs(entry_price - stop_loss_price)
    
    if price_diff == 0:
        raise ValueError("Stop-loss cannot be zero")
    
    # –î–ª—è —Ñ—å—é—á–µ—Ä—Å–æ–≤ USDT-margin —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –≤ USDT
    size_usdt = risk_amount
    
    position_info = f"""Amount: {CAPITAL} USDT
Risk: {RISK_PERCENT}% = {risk_amount:.2f} USDT
Position size: {size_usdt:.2f} USDT"""
    
    print(position_info)
    return size_usdt, position_info